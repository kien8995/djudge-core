#include <stdio.h>
#include <stdlib.h>
#include <stdint.h>
#include <string.h>
#include <math.h>
#include <ctype.h>
#include <locale.h>
#include <limits.h>

#define MAXV 1001

struct corner {
	int x, y;
	int next;
	int dir;
	int already;
};

int ni;
struct corner polygon[MAXV];

int additions[4][2] = {
	{ -1, 0},
	{  0, 1},
	{  1, 0},
	{  0,-1}
};

int find_up(int current)
{
	int y= polygon[current].y;
	int maxy = INT_MIN;
	int maxyi = INT_MAX;
	int i;
	for (i=0; i<ni; i++)
		if (polygon[i].x == polygon[current].x)
		if (polygon[i].y < y && polygon[i].y > maxy) {
			maxy = polygon[i].y;
			maxyi = i;
		}
	return maxyi;
}
int find_down(int current)
{
	int y= polygon[current].y;
	int miny = INT_MAX;
	int minyi = INT_MAX;
	int i;
	for (i=0; i<ni; i++)
		if (polygon[i].x == polygon[current].x)
		if (polygon[i].y > y && polygon[i].y < miny) {
			miny = polygon[i].y;
			minyi = i;
		}
	return minyi;
}
int find_left(int current)
{
	int y= polygon[current].x;
	int maxy = INT_MIN;
	int maxyi = INT_MAX;
	int i;
	for (i=0; i<ni; i++)
		if (polygon[i].y == polygon[current].y)
		if (polygon[i].x < y && polygon[i].x > maxy) {
			maxy = polygon[i].x;
			maxyi = i;
		}
	return maxyi;
}
int find_right(int current)
{
	int y= polygon[current].x;
	int miny = INT_MAX;
	int minyi = INT_MAX;
	int i;
	for (i=0; i<ni; i++)
		if (polygon[i].y == polygon[current].y)
		if (polygon[i].x > y && polygon[i].x < miny) {
			miny = polygon[i].x;
			minyi = i;
		}
	return minyi;
}

int find_next(int current, int direction)
{
	if (direction == 0)
		return find_up(current);
	if (direction == 1)
		return find_right(current);
	if (direction == 2)
		return find_down(current);
	if (direction == 3)
		return find_left(current);
	return INT_MAX;
}
int first;
void calculate_path(int ni)
{
	int miny, minx;
	int minyi, minxi;
	int i;
	int current;
	int direction; /* 0 up, 1 right, 2 down, 3 left */
	miny = INT_MAX;
	for (i=0; i<ni; i++)
		if (polygon[i].y < miny) {
			miny = polygon[i].y;
			minyi = i;
		}
	minx = INT_MAX;
	for (i=0; i<ni; i++)
		if (polygon[i].y == miny)
			if (polygon[i].x < minx) {
				minx = polygon[i].x;
				minxi = i;
			}

	first = minxi;
	current = first;
	direction = 1;
	do {
		int next = find_next(current, direction);
		if (polygon[next].already || next == INT_MAX) {
			direction = (direction+2) % 4;
			next = find_next(current, direction);
		}
		polygon[current].dir = direction;
		polygon[current].already = 1;
		polygon[current].next = next;
		current = next;
		direction = (direction+4-1)%4;
	} while (current != first);
}

void print_path(int ni)
{
	int i;
	int current = 0;
	for (i=0; i<ni; i++) {
		char dir;
		switch (polygon[current].dir) {
			case 0: dir = 'N'; break;
			case 1: dir = 'E'; break;
			case 2: dir = 'S'; break;
			case 3: dir = 'W'; break;
		}
		printf("%c", dir);
		current = polygon[current].next;
	}
	printf("\n");
}
int main(void)
{
	int N;
	setlocale(LC_ALL, "C");


	/* we'll start at vertex with min(x) from group of min(y) */
	while (1) {
	scanf("%d", &N);
	if (N==0)
		break;
	for (ni=0; ni<N; ni++) {
		polygon[ni].next = 0;
		polygon[ni].dir = 0;
		polygon[ni].already = 0;
		scanf("%d %d", &polygon[ni].x, &polygon[ni].y);
		polygon[ni].y = -polygon[ni].y;
	}
	calculate_path(ni);

	print_path(ni);
	}

	return 0;
}
