#include <cstdio>
#include <algorithm>
#include <list>
#include <queue>
#define MN 5001
#define INF 10000000

using namespace std;

int H;
int N;
list<int> Graf[MN];
char Map[MN];
int Odlg[MN][MN];
int OdlgOP[4][MN];
int OdlgOO[4][4];

void BFS(int Y)
{
    queue<int> Kol; Kol.push(Y);
    Odlg[Y][Y] = 0;
    while (!Kol.empty())
    {
	int X = Kol.front(); Kol.pop();
	for (list<int>::iterator j=Graf[X].begin();j!=Graf[X].end();j++)
	{
	    if (Odlg[Y][*j] == INF)
	    {
		Odlg[Y][*j] = Odlg[Y][X]+1;
		Kol.push(*j);
	    }
	}
    }
}

void OdlgDoOb(int Y)
{
    queue<int> Kol; 
    for (int i=0;i<N;i++)
	if (Map[i]-'A' == (char)Y)
	{
	    Kol.push(i);
	    OdlgOP[Y][i] = 0;
	}
    OdlgOO[Y][Y] = 0;

    while (!Kol.empty())
    {
	int X = Kol.front(); Kol.pop();
	for (list<int>::iterator j=Graf[X].begin();j!=Graf[X].end();j++)
	{
	    if (OdlgOP[Y][*j] == INF)
	    {
		OdlgOP[Y][*j] = OdlgOP[Y][X]+1;
		if (Map[*j] != '.')
		    OdlgOO[Y][Map[*j]-'A'] = min(OdlgOO[Y][Map[*j]-'A'],OdlgOP[Y][*j]);
		Kol.push(*j);
	    }
	}
    }	    
}

int main()
{
    while (true)
    {
	scanf("%d",&H);
	
	if (H==0) break;
	
	for (int i=0;i<MN;i++)
	    Graf[i].clear();

	int Akt = 0;
	for (int i=0;i<H;i++)
	{
	    for (int j=0;j<H+i;j++)
	    {
		char C = getchar();
		while ( !(C=='.' || C=='A' || C=='B' || C=='C' || C=='D') )
		    C = getchar();
		Map[Akt++] = C;	
	    }
	}

	for (int i=H-2;i>=0;i--)
	{
	    for (int j=0;j<H+i;j++)
	    {
		char C = getchar();
		while ( !(C=='.' || C=='A' || C=='B' || C=='C' || C=='D') )
		    C = getchar();
		Map[Akt++] = C;		   
	    }
	}

	for (int i=0;i<H;i++)
	{
	    for (int j=0;j<H+i;j++)
	    {
//		N-1,N-H-i-1,N-H-i-2
		if (j>0) 
		{
		    Graf[N].push_back(N-1);
		    Graf[N-1].push_back(N);
		}
		if (j>0 && i>0)// N-H-i-2;
		{
		    Graf[N].push_back(N-H-(i-1)-1);
		    Graf[N-H-(i-1)-1].push_back(N);
		}
		if (j<H+i-1 && i>0)// N-H-i-1;
		{
		    Graf[N].push_back(N-H-(i-1));
		    Graf[N-H-(i-1)].push_back(N);
		}
		N++;
//		printf("%d %d %d\n",N,i,j);
	    }
	}
	for (int i=H-2;i>=0;i--)
	{
	    for (int j=0;j<H+i;j++)
	    {
//		N-1,N-H-i-1,N-H-i-2
		if (j>0) 
		{
		    Graf[N].push_back(N-1);
		    Graf[N-1].push_back(N);
		}
		
		Graf[N].push_back(N-H-i-1);
		Graf[N-H-i-1].push_back(N);
		
		Graf[N].push_back(N-H-i);
		Graf[N-H-i].push_back(N);
		N++;
	    }
	}

	for (int i=0;i<N;i++)
	{
	    for (int j=0;j<N;j++)
		Odlg[i][j] = INF;
	    BFS(i);
	}
	
	for (int i=0;i<4;i++)
	{
	    for (int j=0;j<N;j++)
		OdlgOP[i][j] = INF;
	    for (int j=0;j<4;j++)
		OdlgOO[i][j] = INF;
	    OdlgDoOb(i);
	}
	
	for (int i=0;i<N;i++)
	{
	    for (int j=0;j<N;j++)
//		if (Odlg[i][j] > 0)
		    Odlg[i][j]--;
	    for (int j=0;j<4;j++)
//		if (OdlgOP[j][i] > 0)
		    OdlgOP[j][i]--;
	}
	
	for (int i=0;i<4;i++)
	    for (int j=0;j<4;j++)
//		if (OdlgOO[i][j] > 0)
		OdlgOO[i][j]--;
	
//	for (int i=0;i<4;i++)
//	    for (int j=0;j<4;j++)
//		printf("%d %d: %d\n",i,j,OdlgOO[i][j]);
	
	/*1*/
	
	int Best = INF;
	
	for (int i=0;i<N;i++)
	    for (int j=0;j<N;j++)
		if (Map[i] == '.' && Map[j] == '.')
		{
		    int Plus=2;
//		    if (i==j) Plus = 1; else Plus = 2;
		    int Tym1 = OdlgOP[0][i] + OdlgOP[2][i] + OdlgOP[1][j] + OdlgOP[3][j] + Odlg[i][j] + Plus;
		    int Tym2 = OdlgOP[0][i] + OdlgOP[1][i] + OdlgOP[2][j] + OdlgOP[3][j] + Odlg[i][j] + Plus;
		    int Tym3 = OdlgOP[0][i] + OdlgOP[3][i] + OdlgOP[1][j] + OdlgOP[2][j] + Odlg[i][j] + Plus;
		    Tym1 = min(Tym1,Tym2);
		    Tym1 = min(Tym1,Tym3);
		    Best = min(Best,Tym1);
		}
	
	/*2*/
	
	for (int i=0;i<N;i++)
	if (Map[i]=='.')
	{
	    int Tym[12];
	    Tym[0] = OdlgOP[0][i]+OdlgOP[1][i]+OdlgOP[2][i]+ OdlgOO[0][3];
	    Tym[1] = OdlgOP[0][i]+OdlgOP[1][i]+OdlgOP[2][i]+ OdlgOO[1][3];
	    Tym[2] = OdlgOP[0][i]+OdlgOP[1][i]+OdlgOP[2][i]+ OdlgOO[2][3];

	    Tym[3] = OdlgOP[0][i]+OdlgOP[1][i]+OdlgOP[3][i]+ OdlgOO[0][2];
	    Tym[4] = OdlgOP[0][i]+OdlgOP[1][i]+OdlgOP[3][i]+ OdlgOO[1][2];
	    Tym[5] = OdlgOP[0][i]+OdlgOP[1][i]+OdlgOP[3][i]+ OdlgOO[3][2];

	    Tym[6] = OdlgOP[0][i]+OdlgOP[2][i]+OdlgOP[3][i]+ OdlgOO[0][1];
	    Tym[7] = OdlgOP[0][i]+OdlgOP[2][i]+OdlgOP[3][i]+ OdlgOO[2][1];
	    Tym[8] = OdlgOP[0][i]+OdlgOP[2][i]+OdlgOP[3][i]+ OdlgOO[3][1];

	    Tym[9] = OdlgOP[1][i]+OdlgOP[2][i]+OdlgOP[3][i]+ OdlgOO[1][0];
	    Tym[10] = OdlgOP[1][i]+OdlgOP[2][i]+OdlgOP[3][i]+ OdlgOO[2][0];
	    Tym[11] = OdlgOP[1][i]+OdlgOP[2][i]+OdlgOP[3][i]+ OdlgOO[3][0];
	    
	    for (int j=1;j<12;j++)
		Best = min(Tym[j]+1,Best);
	}
	
	/*3*/
	
	int Tab[4];
	for (int i=0;i<4;i++)
	    Tab[i] = i;
	    
	do
	{
	    int Tym = OdlgOO[ Tab[0] ][ Tab[1] ] +   OdlgOO[ Tab[1] ][ Tab[2] ] +  OdlgOO[ Tab[2] ][ Tab[3] ];
	    Best = min(Best,Tym);
	}while (next_permutation(Tab,Tab+4));
	
	printf("You have to buy %d parcels.\n",Best);
	
//	for (int i=0;i<N;i++)
//	{
//	    printf("%d.: ",i);
//	    for (list<int>::iterator j=Graf[i].begin();j!=Graf[i].end();j++)
//		printf("%d ",*j);
//	    printf("\n");
//	}
	

    }    

    return 0;
}
