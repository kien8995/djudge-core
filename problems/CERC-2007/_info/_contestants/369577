#include <iostream>
#include <cstdio>
#include <cmath>
#include <algorithm>
using namespace std;

#define FOR(i,a,b) for (int i = (a); i < (b); ++i)

const double PI = 3.14159265358979323846264338;
inline bool EQ(double a, double b) { return fabs(a-b) < 1e-9; }

double normalize(double a)
{
	while (a >= 2.0*PI) a -= 2.0*PI;
	while (a < 0.0) a += 2.0*PI;
	return a;
}

int N, r;
double R;
int x[2047], y[2047];

struct event
{
	double angle;
	int point, val;
	
	bool operator<(const event & e) const { return angle < e.angle || (EQ(angle, e.angle) && val > e.val); }
} events[2047*2];

bool active[2047];
int count(int num)
{
	int res = 0, act = 0;
	FOR(i, 0, num)
	{
		if (events[i].val == -1 && !active[events[i].point]) continue;
		if (events[i].val == -1) active[events[i].point] = false;
		else active[events[i].point] = true;

		act += events[i].val;
		res = max(res, act);
	}

	return res;	
}
	
int main()
{
	while (1)
	{
		scanf("%d %d", &N, &r);
		if (!N && !r) break;
		R = (double)r + 0.0005;

		FOR(i, 0, N)
			scanf("%d %d", &x[i], &y[i]);

		int res = 0;
		FOR(i, 0, N)
		{
			int index = 0, init = 0;
			FOR(j, 0, N)
			{
				active[j] =  false;
				if (i == j) continue;
				double xx = x[j] - x[i], yy = y[j] - y[i];
				double dist = sqrt(xx*xx + yy*yy);
				if (dist > 2.0 * (double)R) continue;

				double angle = atan2(yy, xx);				
				double add = asin(dist / (2.0 * (double)R));
				events[index].point = j;
				events[index].val = 1;
				events[index].angle = normalize(angle - add);
				++index;
				events[index].point = j;
				events[index].val = -1;
				events[index].angle = normalize(angle + add);
				++index;
			}
			sort(events, events+index);
			res = max(res, count(index)+1);
		}
		printf("It is possible to cover %d points.\n", res);
	}

	return 0;
}
