#include <cstdio>
#include <utility>
#include <algorithm>
#include <map>

using std::pair;
using std::map;

const int maxpoints = 1000 + 1;
int n;

class point : public pair<int,int>{ public:
	inline int & operator[](int ind){ return ind==0 ? first : second; };
	inline int operator[](int ind) const { return ind==0 ? first : second; };
	void print(){
		printf("{%2d,%2d}", (*this)[0], (*this)[1]);
	};
};
point points[1000];

inline bool horizcomp(const point &a, const point &b){
	if(a[0]!=b[0]) return a[0] < b[0];
	return a[1]<b[1];
};

inline bool vertcomp(const point &a, const point &b){
	if(a[1]!=b[1]) return a[1] < b[1];
	return a[0]<b[0];
};

class walls_cl{ public:
	int **t;
	int *c;
	map<point,point> MV,MH;
	void init(){
		t = new int*[2];
		c = new int[maxpoints+1];
		for(int a=0;a<2;++a){
			t[a] = new int[maxpoints+1];
		};
	};
	void initset(){
		for(int i=0;i<n; ++i) c[i] = 0;
	};
	void pushv(point &a, point &b){
		MV[a] = b;
		MV[b] = a;
#ifdef DEB
		//printf("pushv %3d:",__LINE__); a.print(); b.print(); printf("\n");
#endif
	};
	void pushh(point &a, point &b){
		MH[a] = b;
		MH[b] = a;
#ifdef DEB
		//printf("pushh %3d:",__LINE__); a.print(); b.print(); printf("\n");
#endif
	};

	point nextpoint(point &b, bool horizontal){ // bordger is a->b->c; function returns c
#ifdef DEB
		printf("\tnextpoint("); b.print(); printf(",%s) = ", horizontal ? "H" : "V" );
		point x = (horizontal) ? MH[b] : MV[b];
		x.print(); printf("\n");
#endif
		return (horizontal) ? MH[b] : MV[b];
	};
};

walls_cl walls;

void init(){
	walls.init();
};

void initset(){
#ifdef DEB
	printf("---------NEXT SET----\n");
#endif
	walls.initset();
};

int main(){
	point start, first, p, p0;
	init();
	while (true) {
		bool o = false;
		scanf("%d", &n);
		if (n==0) return 0;
		//printf("%d - DEB\n", __LINE__);
		initset();
		for (int i = 0; i<n; i++) {
			scanf("%d %d", &points[i][0], &points[i][1]);
		}
		start = points[0];
		sort(points, points+n, horizcomp);
		for (int i=0; i<n; i+=2) {
			walls.pushv(points[i], points[i+1]);
		}
		sort(points, points+n, vertcomp);
		for (int i=0; i<n; i+=2) {
			walls.pushh(points[i], points[i+1]);
		}
		first = points[0];
		p = first;
		while (p != start) {
			p = walls.nextpoint(p, o);
			o = !o;
		}
		p0 = start;
		p = walls.nextpoint(p, o);
		if (o) {
			if (p0[0] < p[0]) { printf("E"); } else { printf("W"); }
		} else {
			if (p0[1] < p[1]) { printf("N"); } else { printf("S"); }
		}
		o = !o;
		while (p != start) {
			p0 = p;
			p = walls.nextpoint(p, o);
			if (o) {
				if (p0[0] < p[0]) { printf("E"); } else { printf("W"); }
			} else {
				if (p0[1] < p[1]) { printf("N"); } else { printf("S"); }
			}
			o = !o;
		}
		printf("\n");
	}
	return 0;
};

