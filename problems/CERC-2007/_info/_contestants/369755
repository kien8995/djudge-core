#include <stdio.h>

struct pole {
	char z;
	int n,b,y,r,g;
};

struct mark {
	int x,y,steps;
};


int main()
{
	struct mark q[50000];
	struct pole plan[100][100];
	
	int rows, cols, i, j, k;
	char c;
	
	while (1)
	{
		scanf("%d %d\n", &rows, &cols);
		
		if (!rows && !cols) break;
		
		int sx,sy;
		
		for (i=0; i<rows; i++)
		{
			for (j=0; j<cols; j++)
			{
				scanf("%c", &c);
				if (c=='*') {sx = j; sy = i; }
				plan[j][i].z = c;
				plan[j][i].n = 0;
				plan[j][i].b = 0;
				plan[j][i].y = 0;
				plan[j][i].r = 0;
				plan[j][i].g = 0;
			}
			scanf("%c", &c);
		}
		
		int qb,qe;
		qb = 0;
		qe = 1;
		q[0] = (struct mark){sx, sy, 0};
		plan[sx][sy].n = 1;
		
		struct mark p;
		
		int found = 0;
		
		while (qb < qe)
		{
			p = q[qb++];
			/*printf("%d %d\n", p.x, p.y);
			*/
			if (plan[p.x][p.y].z == 'X')
			{
				found = 1;
				printf("Escape possible in %d steps.\n",
				      p.steps);
				break;
			}
			
			struct mark m[4];
			m[0].x = p.x-1; m[0].y = p.y;
			m[1].x = p.x+1; m[1].y = p.y;
			m[2].x = p.x; m[2].y = p.y-1;
			m[3].x = p.x; m[3].y = p.y+1;
			
			for (k=0; k<4; k++)
			{
				/* mimo plan */
				if (m[k].x < 0 || m[k].x >= cols) continue;
				if (m[k].y < 0 || m[k].y >= rows) continue;
				
				if (plan[m[k].x][m[k].y].z == '#') continue;
				
				if (plan[m[k].x][m[k].y].z == 'R' && !plan[p.x][p.y].r) continue;
				if (plan[m[k].x][m[k].y].z == 'G' && !plan[p.x][p.y].g) continue;
				if (plan[m[k].x][m[k].y].z == 'Y' && !plan[p.x][p.y].y) continue;
				if (plan[m[k].x][m[k].y].z == 'B' && !plan[p.x][p.y].b) continue;
				
				/* zapis nove nalezenmeho klice */
				if (plan[m[k].x][m[k].y].z == 'r')
					plan[m[k].x][m[k].y].r = 1;
				if (plan[m[k].x][m[k].y].z == 'g')
					plan[m[k].x][m[k].y].g = 1;
				if (plan[m[k].x][m[k].y].z == 'b')
					plan[m[k].x][m[k].y].b = 1;
				if (plan[m[k].x][m[k].y].z == 'y')
					plan[m[k].x][m[k].y].y = 1;
				
				int sirit = 0;
				if (plan[p.x][p.y].n && !plan[m[k].x][m[k].y].n) sirit = 1;
				if (!sirit && plan[p.x][p.y].y && !plan[m[k].x][m[k].y].y) sirit = 1;
				if (!sirit && plan[p.x][p.y].b && !plan[m[k].x][m[k].y].b) sirit = 1;
				if (!sirit && plan[p.x][p.y].g && !plan[m[k].x][m[k].y].g) sirit = 1;
				if (!sirit && plan[p.x][p.y].r && !plan[m[k].x][m[k].y].r) sirit = 1;
				
				if (!sirit) continue;
				
				plan[m[k].x][m[k].y].n |= plan[p.x][p.y].n;
				plan[m[k].x][m[k].y].b |= plan[p.x][p.y].b;
				plan[m[k].x][m[k].y].r |= plan[p.x][p.y].r;
				plan[m[k].x][m[k].y].g |= plan[p.x][p.y].g;
				plan[m[k].x][m[k].y].y |= plan[p.x][p.y].y;
				
				/*printf(" adding %d %d\n", m[k].x, m[k].y);
				*/
				q[qe++] = (struct mark){ m[k].x, m[k].y, p.steps+1 };
			}
			
			
			
		}
		
		if (!found)
		{
			printf("The poor student is trapped!\n");
		}
	}
	
	
	return 0;
}
