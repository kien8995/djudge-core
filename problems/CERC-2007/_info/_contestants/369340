#include <cstdio>
#include <queue>
#include <algorithm>
#define MN 101
#define LK 16
#define MAXI 10000001

using namespace std;

int R,C;
int Dis[MN][MN][LK];
bool Odw[MN][MN][LK];
char Map[MN][MN];
int SX,SY;

struct Node
{
    int X,Y,K;
    Node(int A,int B,int Q):X(A),Y(B),K(Q){}
};

inline int Abs(int A)
{
    if (A>0) return A; else return -A;
}

inline int Key(char X)
{
    if (X == 'b') return 1;
    if (X == 'y') return 2;
    if (X == 'r') return 4;
    if (X == 'g') return 8;
}

int main()
{
    while (true)
    {
	scanf("%d%d",&R,&C);
	if (R==0 && C==0) break;
	getchar();
	for (int i=1;i<=R;i++)
	{
	    for (int j=1;j<=C;j++)
		Map[i][j] = getchar();
	    getchar();
	}

	for (int i=1;i<=R;i++)
	    for (int j=1;j<=C;j++)
	    {
		if (Map[i][j] == '*')
		{
		    SX = i;
		    SY = j;
		    Map[i][j] = '.';
		}
		for (int l=0;l<LK;l++)
		{
		    Dis[i][j][l] = MAXI;
		    Odw[i][j][l] = false;
		}
	    }
	    
	Dis[SX][SY][0] = 0;
	
	queue<Node> Kol;
	Kol.push( Node(SX,SY,0) );
	
	while (!Kol.empty())
	{
	    Node N = Kol.front(); Kol.pop();
//	    printf("%d %d %d %d\n",N.X,N.Y,Dis[N.X][N.Y][N.K],N.K);
	    if (Odw[N.X][N.Y][N.K] || Map[N.X][N.Y] == 'X') continue; else Odw[N.X][N.Y][N.K] = true;

//	    printf("%d %d %d %d\n",N.X,N.Y,Dis[N.X][N.Y][N.K],N.K);
	    for (int i=-1;i<=1;i++)
		for (int j=-1;j<=1;j++)
		{
		    if (N.X+i > 0 && N.X+i <= R &&
			N.Y+j > 0 && N.Y+j <= C &&
			Abs(i)+Abs(j) == 1)
		    {
			Node S(N.X+i,N.Y+j,N.K);
			if (Map[S.X][S.Y] >= 'a' && Map[S.X][S.Y] <= 'z')
			{
			    S.K |= Key(Map[S.X][S.Y]);
			    Dis[S.X][S.Y][S.K] = Dis[N.X][N.Y][N.K]+1;
			    if (!Odw[S.X][S.Y][S.K])
				Kol.push(S);
			}
			else
			if (Map[S.X][S.Y] >= 'A' && Map[S.X][S.Y] <= 'Z' && Map[S.X][S.Y] != 'X')
			{
			    if ( (Key(Map[S.X][S.Y]-'A'+'a') & N.K) > 0 )
			    {
				Dis[S.X][S.Y][S.K] = Dis[N.X][N.Y][N.K]+1;
				if (!Odw[S.X][S.Y][S.K])
			    	    Kol.push(S);
			    }
			}
			else
			if ((Map[S.X][S.Y] == '.') || (Map[S.X][S.Y] == 'X'))
			{
			    Dis[S.X][S.Y][S.K] = Dis[N.X][N.Y][N.K]+1;
			    if (!Odw[S.X][S.Y][S.K])
				Kol.push(S);
			}
		    }
		}
	}
	    
	int Best = MAXI;
	for (int i=1;i<=R;i++)
	    for (int j=1;j<=C;j++)
	    {
		if (Map[i][j] == 'X')
			for (int l=0;l<LK;l++)
			    Best = min(Dis[i][j][l],Best);
	    }
	if (Best == MAXI)
	    printf("The poor student is trapped!\n");
	else
	    printf("Escape is possible in %d steps.\n",Best);
    }
    return 0;
}

