#include <iostream>
#include <cstdio>
#include <set>
#include <map>
#include <vector>
#include <utility>
#include <algorithm>
#include <complex>
#include <queue>
#include <cmath>
#include <string>
#include <cstdlib>
#include <cstring>
using namespace std;

typedef pair<double, int> PI;
const double pi = 2*acos(0.0);
#define REP(i,n) for (int i=0; i<int(n); i++)
#define FOR(i,a,n) for (int i=a; i<int(n); i++)
#define FORD(i,n) for (int i=int(n)-1; i>=0; i--)
#define FOREACH(it,a) for (__typeof(a.begin()) it=a.begin(); it!=a.end(); it++)
double norm(double a) {
    while (a<0) a += 2*pi;
    while (a>=2*pi) a-=2*pi;
    return a;
}
typedef long long ll;
ll sq(ll a, ll b) {
    return a*a+b*b;
}
int main() {
    int n, r;
    int x[3000], y[3000];
    while (scanf("%d %d", &n, &r)==2) {
        if (!n && !r) break;
        REP(i,n)
            scanf("%d %d", &x[i], &y[i]);

        int res=0;
        REP(i,n) {
            vector<PI> b;
            int kol=1;
            REP(j,n) if (j!=i) {
                if (sq(x[i]-x[j], y[i]-y[j]) > 4*r*r) continue;
                double v=hypot(x[i]-x[j], y[i]-y[j]);
                double a = acos(v/(2*r+0.002));
                double c = atan2(x[i]-x[j], y[i]-y[j]);
                b.push_back(PI(norm(c-a), +1));
                b.push_back(PI(norm(c+a), -1));

                int uu=b.size()-2;
                if (b[uu+1].first < b[uu].first) kol++;
            }
            sort(b.begin(), b.end());
            REP(j,b.size()) {
                res = max(res, kol);
                kol += b[j].second;
            }
            res = max(res, kol);
        }
        printf("It is possible to cover %d points.\n", res);
    }
} 
