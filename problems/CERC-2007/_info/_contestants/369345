#include <cstdio>
#include <iostream>
#include <algorithm>
#include <iterator>
#include <string>
#include <vector>
#include <cmath>
#include <set>
#include <map>
#include <queue>
#include <numeric>
#include <list>
#include <cstring>
#include <cctype>
#include <sstream>

using namespace std;

typedef long long LL;
typedef long double LD;
typedef vector<int> VI;
typedef pair<int,int> PII;
typedef vector<PII> VPII;

#define MP make_pair
#define ST first
#define ND second
#define PB push_back
#define FOR(i,a,b) for( int i=(a); i<=(b); ++i)
#define FORD(i,a,b) for( int i=(a); i>=(b); --i)
#define REP(i,n) for(int i=0; i<(n); ++i)
#define ALL(X) (X).begin(),(X).end()
#define SIZE(X) (int)(X).size()
#define FOREACH(it,X) for(__typeof((X).begin()) it=(X).begin(); it!=(X).end(); ++it)

int dist(PII a, PII b){
	if (a.ST > b.ST) swap(a, b);
	int ile = max(0, min(b.ST-a.ST, b.ND - a.ND));
	return abs(b.ST-a.ST) + abs(b.ND-a.ND) - ile - 1;
}

int distv(PII a, VPII &b){
	int di = 1000*1000;
	FOREACH(it, b) di = min(di, dist(a, *it));
	return di;
}

int distvv(VPII &a, VPII &b){
	int di = 1000*1000;
	FOREACH(it, a) di = min(di, distv(*it, b));
	return di;
}

int t[10][10]; int fau[10];
int ojc(int x){ return fau[x] < 0 ? x : fau[x] = ojc(fau[x]); }
bool join(int x, int y){
	x = ojc(x); y = ojc(y);
	if (x == y) return false;
	if (fau[x] > fau[y]) swap(x, y);
	fau[x] +=fau[y];
	fau[y] = x;
	return true;
}

int mst(int n){
	REP(i, n) fau[i] = -1;
	vector<pair<int, PII > > kr;
	REP(i, n) REP(j, i) kr.PB(MP(t[i][j], MP(i, j)));
	sort(ALL(kr));
	int  s=0;
	FOREACH(it, kr)
		if (join(it->ND.ST, it->ND.ND))
			s += it->ST;
	return s;
}

vector<PII> wolne;
vector<PII> pola[4];
int wold[4][2000];
int main(){
	while(1){
		int n;
		scanf("%d", &n);
		if (!n) break;
		wolne.clear();
		REP(i, 4) pola[i].clear();
		REP(y, 2*n-1){
			int px = max(0, y - n +1 );
			int py = min(2*n-2, y+n-1);
			char txt[10];
			FOR(x, px, py){
				scanf("%s", txt);
				if (txt[0] == '.')
					wolne.PB(MP(x, y));
				else
					pola[txt[0]-'A'].PB(MP(x, y));
			}
		}
		REP(i, 4) REP(j, i) t[i][j] = t[j][i] = distvv(pola[i], pola[j]);
		int m = SIZE(wolne);
		REP(j, 4) REP(i, m) wold[j][i] = distv(wolne[i], pola[j]);
		int wynik = mst(4);
		REP(i, m){
			REP(j, 4) t[j][4] = t[4][j] = wold[j][i];
			wynik = min(wynik, mst(5)+1);
			REP(k, i){
				REP(j, 4) t[j][5]= t[5][j] = wold[j][k];
				t[5][4] = t[4][5] = dist(wolne[i], wolne[k]);
				wynik = min(wynik, mst(6)+2);
			}
		}
		printf("You have to buy %d parcels.\n", wynik);
	}
	return 0;
}
