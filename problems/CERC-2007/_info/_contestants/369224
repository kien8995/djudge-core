#include <cstdio>
#include <cstring>
#include <algorithm>
#include <utility>
#include <cmath>
#include <vector>
#include <cstdarg>
#include <cstdlib>

#define FOR(i, v) for (int i = 0; i < v; i++)
#define FORD(i, v) for (int i = v - 1; i >= 0; i--)
#define REP(i, v, x) for (int i = v; i <= x; i++)
#define REPD(i, v, x) for (int i = v; i >= x; i--)

#define pb push_back
#define fi first
#define se second
#define mp make_pair

#define MAXB 1000

using namespace std;

typedef long long i64;
typedef unsigned long long u64;

char buf[MAXB];

//fgets(buf, MAXB, stdin);
void read(int n, char *s, ...)
{
  int p = 0, v;
  va_list par;
  va_start(par, s);
  while (n--)
  {
    while (s[p] == ' ') p++;
    v = 0;
    while (isdigit(s[p])) v = v * 10 + s[p++] - '0';
    *(va_arg(par, int*)) = v;
  }
  va_end(par);
}

int n, start;
bool pox;
bool pon;
struct point 
{ 
  int x, y, nr, to; 
  char dir;
  bool operator<(const point &b) const
  {
    if (pon) return nr < b.nr;
    if (pox) return (x == b.x) ? y < b.y : x < b.x;
    else return (y == b.y) ? x < b.x : y < b.y;
  }
} pt[1100];
vector<int> g[1100];
bool vis[1100];

void dfs(int w)
{
  vis[w] = true;
  FOR(i, 2) if (!vis[g[w][i]])
  {
    int next = g[w][i];
    pt[w].to = next;
    if (pt[w].x == pt[next].x)
      if (pt[w].y < pt[next].y) pt[w].dir = 'N';
      else pt[w].dir = 'S';
    else
      if (pt[w].x < pt[next].x) pt[w].dir = 'E';
      else pt[w].dir = 'W';
    dfs(next);
    return;
  }
  pt[w].to = start;
  pt[w].dir = 'W';
}

int main()
{
  while (1)
  {
    memset(vis, false, sizeof(vis));
    scanf("%d", &n);
    if (!n) break;
    FOR(i, n) scanf("%d %d", &pt[i].x, &pt[i].y), pt[i].nr = i, g[i].clear();
    pon = false;
    //x
    pox = true;
    sort(pt, pt+n);
    FOR(i, n) 
    {
      int li = i;
      while (li < n - 1 && pt[li + 1].x == pt[i].x) li++;
      REP(j, i, li)
      {
        g[pt[j].nr].pb(pt[j+1].nr);
        g[pt[j+1].nr].pb(pt[j].nr);
        j++;
      }
      i = li;
    }
    //y
    pox = false;
    sort(pt, pt+n);
    FOR(i, n) 
    {
      int li = i;
      while (li < n - 1 && pt[li + 1].y == pt[i].y) li++;
      REP(j, i, li)
      {
        g[pt[j].nr].pb(pt[j+1].nr);
        g[pt[j+1].nr].pb(pt[j].nr);
        j++;
      }
      i = li;
    }
    // res
    start = pt[0].nr;
    int next;
    pon = true;
    sort(pt, pt+n);
    if (pt[g[start][0]].x == pt[start].x) next = g[start][0];
    else next = g[start][1];
    vis[start] = true;
    vis[next] = true;
    pt[start].to = next;
    pt[start].dir = 'N';
    dfs(next);
    int act = 0;
    FOR(i, n)
    {
      printf("%c", pt[act].dir);
      act = pt[act].to;
    }
    printf("\n");
  }
  return 0;
}
