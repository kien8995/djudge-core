#include <stdio.h>
#include <vector>
#include <algorithm>
#include <cmath>
using namespace std;

int A[2000][2];

int dist(int a, int b) {
	return (A[a][0] - A[b][0]) * (A[a][0] - A[b][0]) + (A[a][1] - A[b][1]) * (A[a][1] - A[b][1]);
}

bool eq (double a, double b) {
	return abs(a - b) < 1e-9;
}

bool cmp (const pair<double,int> &a, const pair<double,int> &b) {
	if (eq(a.first, b.first)) {
		if (a.second == 1) return 1;
		else return 0;
	}else return a.first < b.first;
}

int main () {
	int n,r;
	while (1) {
		scanf("%d %d",&n,&r);
		if (n == 0 && r == 0) break;
		for (int i = 0; i < n; i++) scanf("%d %d",&A[i][0],&A[i][1]);
		int res = 1;
		for (int i = 0; i < n; i++) {
			//printf("## %d %d\n",A[i][0],A[i][1]);
			vector < pair<double,int> > tmp;
			for (int j = 0; j < n; j++) if (i != j && dist(i,j) <= 4*r*r) {
			//	printf("%d %d - %.5lf\n",A[j][0],A[j][1], sqrt(1.0*dist(i,j)));
				double alpha = atan2(abs(A[i][0] - A[j][0]), abs(A[i][1] - A[j][1]));
				if (A[j][0] >= A[i][0] && (A[j][0] != A[i][0] || A[j][1] > A[i][1])) alpha += 2*acos(0);
			//	printf("%lf\n",alpha);
				double x = sqrt(dist(i,j));
				double beta = acos(x/(2*r));
			//	printf("%lf (%lf / %d)\n",beta,x,2*r);
				double chuj = alpha - beta;
				double babij = alpha + beta;
				while (chuj < 0) chuj += 4*acos(0);
				while (chuj > 4*acos(0)) chuj -= 4*acos(0);
				while (babij < 0) babij += 4*acos(0);
				while (babij > 4*acos(0)) babij -= 4*acos(0);
				tmp.push_back(make_pair(chuj, 1));
				tmp.push_back(make_pair(babij, -1));
			}
			sort(tmp.begin(), tmp.end(), cmp);
			int dupa = 0, cur = 0;
		//	printf("-> %d\n",tmp.size());
			for (int j = 0; j < tmp.size(); j++) {
			//	printf("%lf %d\n",tmp[j].first,tmp[j].second);
				cur += tmp[j].second;
				res >?= cur;
			}
			//printf("%d\n\n",dupa);
		}
		printf("It is possible to cover %d points.\n",res + 1);
	}
	return 0;
}
