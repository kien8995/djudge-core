#include <iostream>
#include <cstdio>
#include <cmath>
using namespace std;

#define FOR(i,a,b) for (int i = (a); i < (b); ++i)

struct Vector
{
	double x, y;
	Vector(): x(0.0), y(0.0) { }
	Vector(double xx, double yy): x(xx), y(yy) { }

	void operator+=(const Vector & v) { x += v.x; y += v.y; }
	Vector operator+(const Vector & v) const { return Vector(x+v.x, y+v.y); }
	Vector operator-(const Vector & v) const { return Vector(x-v.x, y-v.y); }
	
	void operator*=(double n) { x *= n; y *= n; }
	Vector operator*(double n) const  { return Vector(x*n, y*n); }
	void operator/=(double n) { x /= n; y /= n; }
	Vector operator/(double n) const  { return Vector(x/n, y/n); }

	double size2() const { return x*x + y*y; }
	double size() const { return sqrt(x*x+y*y); }
};

int N, R;
double R2;
Vector points[2047];

int count(const Vector & centre)
{
	int res = 0;
	FOR(i, 0, N)
		if (Vector(points[i] - centre).size2() <= R2) ++res;
	return res;
}

int main()
{
	while (1)
	{
		scanf("%d %d", &N, &R);
		if (!N && !R) break;

		R2 = R;
		R2 += 0.001;
		R2 *= R2;

		int x, y;
		FOR(i, 0, N)
		{
			scanf("%d %d", &x, &y);
			points[i].x = x;
			points[i].y = y;
		}

		int res = 0;
		FOR(i, 0, N)
			FOR(j, 0, N)
			{
				if (i == j) continue;
				Vector middle = (points[i] + points[j]) / 2.0;
				
				double a2 = Vector(points[i] - middle).size2();
				if (a2 > R2) continue;

				Vector dir(points[i].y - points[j].y, points[j].x - points[i].x);
				dir /= dir.size();
				double b = sqrt(R2 - a2);
				dir *= b;
				middle += dir;
				res = max(res, count(middle));
			}
		
		if (res == 0) ++res;
		printf("It is possible to cover %d points.\n", res);
	}

	return 0;
}
