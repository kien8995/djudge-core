#include <cstdio>
#include <iostream>
#include <algorithm>
#include <iterator>
#include <string>
#include <vector>
#include <cmath>
#include <set>
#include <map>
#include <queue>
#include <numeric>
#include <list>
#include <cstring>
#include <cctype>
#include <sstream>

using namespace std;

typedef long long LL;
typedef long double LD;
typedef vector<int> VI;
typedef pair<int,int> PII;
typedef vector<PII> VPII;

#define MP make_pair
#define ST first
#define ND second
#define PB push_back
#define FOR(i,a,b) for( int i=(a); i<=(b); ++i)
#define FORD(i,a,b) for( int i=(a); i>=(b); --i)
#define REP(i,n) for(int i=0; i<(n); ++i)
#define ALL(X) (X).begin(),(X).end()
#define SIZE(X) (int)(X).size()
#define FOREACH(it,X) for(__typeof((X).begin()) it=(X).begin(); it!=(X).end(); ++it)

const int N=510;
const int BRAMKI=201*201;
int wartosc_bramki[BRAMKI];
int rodzaj_bramki[BRAMKI];
char plansza[N][N];

VI stos;

int dx[]={-1,0,1,0};
int dy[]={0,1,0,-1};

const int AND=1;
const int OR=2;
const int XOR=3;

int vis_propaguj[N][N];
const int K=26;
int wyjscie[K];
int numer_bramki[N][N];
int wejscia[BRAMKI];

void wejsc_do_bramki(int bramka,int co){
	switch (rodzaj_bramki[bramka]){
		case AND: 
			if (co==0) wartosc_bramki[bramka]=0;
			break;
		case OR: 
			if (co==1) wartosc_bramki[bramka]=1;
			break;
		case XOR: 
			if (co==1) wartosc_bramki[bramka]^=1;
			break;
	}
	if (--wejscia[bramka]==0) stos.PB(bramka);
}

int wiersze,kol;

void propaguj(int i,int j,int kier,int co){
	if (vis_propaguj[i][j]) return;
	vis_propaguj[i][j]=1;
	if (plansza[i][j]=='='){
		if (plansza[i][j+1]=='#'){
			int ktora=numer_bramki[i][j+1];
			wejsc_do_bramki(ktora,co);
		} else if (isupper(plansza[i][j+1])) wyjscie[plansza[i][j+1]-'A']=co;
		else{
			propaguj(i,j+1,1,co);
		}
	} else if (plansza[i][j]=='-'){
		propaguj(i,j+1,1,co);
		propaguj(i,j-1,3,co);
	} else if (plansza[i][j]=='|'){
		propaguj(i+1,j,2,co);
		propaguj(i-1,j,0,co);
	} else if (plansza[i][j]=='+'){
		if (i>0){
			char c=plansza[i-1][j];
			if (c=='+' || c=='x' || c=='|') propaguj(i-1,j,0,co);
		}
		if (i+1<wiersze){
			char c=plansza[i+1][j];
			if (c=='+' || c=='x' || c=='|') propaguj(i+1,j,2,co);
		}
		if (j+1<kol){
			char c=plansza[i][j+1];
			if (c=='+' || c=='x' || c=='-' || '=') propaguj(i,j+1,1,co);
		}
		if (j>0){
			char c=plansza[i][j-1];
			if (c=='+' || c=='x' || c=='-') propaguj(i,j-1,3,co);
		}
	} else if (plansza[i][j]=='x'){
		vis_propaguj[i][j]=0;
		propaguj(i+dx[kier],j+dy[kier],kier,co);
	}
}

int vis[N][N];
int mini,maxi,minj,maxj;


void dfs(int i,int j,int numer){
	vis[i][j]=1;
	numer_bramki[i][j]=numer;
	mini=min(i,mini); minj=min(j,minj);
	maxi=max(i,maxi); maxj=max(j,maxj);
	REP(ruch,4){
		int ni=i+dx[ruch];
		int nj=j+dy[ruch];
		if (ni>=0 && ni<wiersze && nj>=0 && nj<kol && !vis[ni][nj] && plansza[ni][nj]=='#') dfs(ni,nj,numer);
	}
}

PII wymiary[BRAMKI][2];


int main(){
	stos.reserve(BRAMKI);
	while (fgets(plansza[0],N-1,stdin),plansza[0][0]!='*'){
		wiersze=1;
		while (fgets(plansza[wiersze],N-1,stdin),plansza[wiersze][0]!='*') wiersze++;
		kol=0;
		REP(i,wiersze) kol=max(kol,(int)strlen(plansza[i]));
		REP(i,wiersze){
			int j=strlen(plansza[i]);
			REP(foo,j) if (plansza[i][j]==10 || plansza[i][j]==13) plansza[i][j]=' ';
			while (j<kol) plansza[i][j]=' ',j++;
			plansza[i][kol]='\0';
		}
		REP(i,wiersze) REP(j,kol) vis[i][j]=vis_propaguj[i][j]=0;
		int bramki=0;
		REP(i,wiersze) REP(j,kol) if (!vis[i][j] && plansza[i][j]=='#'){
			mini=maxi=i;
			minj=maxj=j;

			dfs(i,j,bramki);
			wymiary[bramki][0]=MP(mini,maxi);
			wymiary[bramki][1]=MP(minj,maxj);

			rodzaj_bramki[bramki]=0;
			FOR(a,mini+1,maxi-1){
				FOR(b,minj+1,maxj-1){
					if (plansza[a][b]=='&') rodzaj_bramki[bramki]=AND;
					else if (plansza[a][b]=='=') rodzaj_bramki[bramki]=XOR;
					else if (plansza[a][b]=='1') rodzaj_bramki[bramki]=OR;
					plansza[a][b]=' ';
				}
			}
			if (rodzaj_bramki[bramki]==0) puts("ERROR brak numeru bramki");
			wejscia[bramki]=0;
			switch (rodzaj_bramki[bramki]){
				case AND: wartosc_bramki[bramki]=1; break;
				case OR: wartosc_bramki[bramki]=0; break;
				case XOR: wartosc_bramki[bramki]=0; break;
			}
			FOR(a,mini,maxi) if (minj>0 && plansza[a][minj-1]=='=') wejscia[bramki]++;
			bramki++;
		}
		REP(i,K) wyjscie[i]=-1;
		stos.clear();
		REP(i,bramki) if (wejscia[i]==0) stos.PB(i);
		REP(i,wiersze) REP(j,kol){
			if (plansza[i][j]=='0'){
				if (plansza[i][j+1]!='=') puts("blad przy 0/1");
				propaguj(i,j+1,1,0);
			} else if (plansza[i][j]=='1'){
				if (plansza[i][j+1]!='=') puts("blad przy 0/1");
				propaguj(i,j+1,1,1);
			}
		}
		while (!stos.empty()){
			int x=stos.back();
			stos.pop_back();
			int a=wymiary[x][0].ST;
			int b=wymiary[x][0].ND;

			int prawo=wymiary[x][1].ND+1;
			FOR(i,a,b) if (plansza[i][prawo]=='o'){
				if (plansza[i][prawo+1]!='=') puts("ERROR przy negacji");
				propaguj(i,prawo+1,1,1-wartosc_bramki[x]);
			} else if (plansza[i][prawo]=='='){
				propaguj(i,prawo,1,wartosc_bramki[x]);
			}
		}
		REP(i,K) if (wyjscie[i]!=-1) printf("%c=%d\n",'A'+i,wyjscie[i]);
		puts("");
	}
	return 0;
}
