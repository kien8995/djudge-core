#include <cstdio>
#include <algorithm>
#include <vector>
#include <string>
#include <set>
#include <map>
#include <list>
#include <stack>
#include <queue>
#include <deque>
#include <cmath>
#include <iostream>
#include <sstream>

using namespace std;

typedef vector<int> VI;
typedef vector<VI> VII;
typedef vector<string> VS;
typedef long long lint;
typedef long long LL;
typedef string ST;

#define VAR(v,n) typeof(n) v=(n)
#define REP(i,n) for(int i=0; i<(n); i++)
#define FOR(i,a,b) for(int i=(a); i<=(b); i++)
#define FORD(i,a,b) for(int i=(a); i>=(b); i--)
#define FOREACH(i,c) for(VAR(i,(c).begin()); i!=(c).end(); i++)

#define PB push_back
#define PF push_front
#define PI pair<int,int>
#define MP make_pair
#define FI first
#define SE second
#define VR vector
#define IT iterator
#define ALL(x) (x).begin(),(x).end()
#define SIZE(x) ((int)(x).size())
#define CLEAR(c,w) memset(c,w,sizeof(c))

struct point {
	double x,y;
};

const double eps=1e-8;

struct event {
	int p,k;
	double alfa;
	
	bool operator<(const event &e) const {
		if (fabs(alfa-e.alfa)>eps) return alfa<e.alfa;
		if (k==+1) return true;
		return false;
		
	}
};

double dist(point A,point B) {
	return sqrt((A.x-B.x)*(A.x-B.x)+(A.y-B.y)*(A.y-B.y));
}

const int N = 2000;

int n;
double r;
point P[N];

int evs;
event E[N*2];

int O[N];

int main() {
	scanf("%d %lf",&n,&r); r+=1e-5;
	while (n) {
		
	REP(i,n) {
		scanf("%lf %lf",&P[i].x,&P[i].y);
	}
	int w=1;
	REP(i,n) {
	//int i=0; {
		double d,a,baza,dx,dy;
		evs=0;
		REP(j,n) if (j!=i) {
			d=dist(P[i],P[j])/2.0;
			if (d>r) continue;
			a=acos(d/r);
			dx=P[j].x-P[i].x;
			dy=P[j].y-P[i].y;
			if (dy>=0)
				baza=acos(dx/(2.0*d));
			else 
				baza=2*M_PI-acos(dx/(2.0*d));
			
			E[evs].alfa=baza-a; E[evs].p=j; E[evs].k=+1; evs++;
			E[evs].alfa=baza+a; E[evs].p=j; E[evs].k=-1; evs++;
		}
		sort(E,E+evs);
		
		REP(j,evs) {
			//printf("%lf %d %d\n",E[j].alfa,E[j].p,E[j].k);
		}
		
		int t=0;
		REP(j,n) O[j]=0;
		REP(j,2*evs) {
			int q=j%evs;
			int p=E[q].p;
			if (E[q].k==-1) {
				if (O[p]) {
					O[p]=0;
					t--;
				}
			} else if (E[q].k==1) {
				t++;
				O[p]=1;
			}
			if (t+1>w) w=t+1;
		}
	}
	printf("It is possible to cover %d points.\n",w);
	
	scanf("%d %lf",&n,&r); r+=1e-5;
	}
	return 0;
}
