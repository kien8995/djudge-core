#include <cstdio>
#include <algorithm>
#include <vector>
#include <string>
#include <set>
#include <map>
#include <list>
#include <stack>
#include <queue>
#include <deque>
#include <cmath>
#include <iostream>
#include <sstream>

using namespace std;

typedef vector<int> VI;
typedef vector<VI> VII;
typedef vector<string> VS;
typedef long long lint;
typedef long long LL;
typedef string ST;

#define VAR(v,n) typeof(n) v=(n)
#define REP(i,n) for(int i=0; i<(n); i++)
#define FOR(i,a,b) for(int i=(a); i<=(b); i++)
#define FORD(i,a,b) for(int i=(a); i>=(b); i--)
#define FOREACH(i,c) for(VAR(i,(c).begin()); i!=(c).end(); i++)

#define PB push_back
#define PF push_front
#define PI pair<int,int>
#define MP make_pair
#define FI first
#define SE second
#define VR vector
#define IT iterator
#define ALL(x) (x).begin(),(x).end()
#define SIZE(x) ((int)(x).size())
#define CLEAR(c,w) memset(c,w,sizeof(c))

const int R[4][2]={{0,1},{0,-1},{1,0},{-1,0}};

struct pos{
	char y,x;
	bool k[4];
	int st;
	pos(char ny,char nx,bool b1,bool b2,bool b3,bool b4,int stn){
		y=ny,x=nx,k[0]=b1,k[1]=b2,k[2]=b3,k[3]=b4,st=stn;
	}
};

bool vis[110][110][2][2][2][2];

char M[110][110],buf[110];

int Y,X;
int px,py;

char chn(char x){
	if(x=='#')return -1;
	if(x=='B')return 0;
	if(x=='Y')return 1;
	if(x=='R')return 2;
	if(x=='G')return 3;
	if(x=='b')return 4;
	if(x=='y')return 5;
	if(x=='r')return 6;
	if(x=='g')return 7;
	if(x=='.')return 8;
	if(x=='*')return 8;	
	if(x=='X')return 9;
	return -1;
}

int main() {
	while(true){
		scanf("%d %d",&Y,&X);
		if(Y==0 && X==0)break;
		CLEAR(vis,0);
		FOR(i,0,X+1)M[0][i]=M[Y+1][i]=-1;
		FOR(i,0,Y+1)M[i][0]=M[i][X+1]=-1;
		FOR(y,1,Y){
			scanf("%s",buf);
			FOR(x,1,X){
				if(buf[x-1]=='*')px=x,py=y;
				M[y][x]=chn(buf[x-1]);
			}
		}
		deque<pos> Q;
		Q.PB(pos(py,px,false,false,false,false,0));
		int ret=-1;
		while(!Q.empty()){
			pos a=Q.front();Q.pop_front();
			if(M[a.y][a.x]==9){ret=a.st; break;}
			REP(i,4){
				int ny=a.y+R[i][0],nx=a.x+R[i][1];
				if(M[ny][nx]==-1)continue;
				if(M[ny][nx]<4 && a.k[M[ny][nx]]==false)continue;
				int k=4;
				if(3<M[ny][nx] && M[ny][nx]<8)k=M[ny][nx]-4;
				if(vis[ny][nx][a.k[0]||(k==0)][a.k[1]||(k==1)][a.k[2]||(k==2)][a.k[3]||(k==3)])continue;
				Q.PB(pos(ny,nx,a.k[0]||(k==0),a.k[1]||(k==1),a.k[2]||(k==2),a.k[3]||(k==3),a.st+1));
				vis[ny][nx][a.k[0]||(k==0)][a.k[1]||(k==1)][a.k[2]||(k==2)][a.k[3]||(k==3)]=true;
			}
		}
		if(ret==-1)printf("The poor student is trapped!\n");
		else printf("Escape possible in %d steps.\n",ret);
		
		
	}
	return 0;
}






