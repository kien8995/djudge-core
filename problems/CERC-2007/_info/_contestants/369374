#include<cstdio>
#include<cstdlib>
#include<cstring>
#include<climits>
#include<cmath>
#include<algorithm>

using namespace std;

#define PRINTF(args...) printf(args)
//#define PRINTF(args...) 

#define FOR(i,a,b) for(int i=(a); i<(int)(b); ++i)
#define FORD(i,a,b) for(int i=(a)-1; i>=(int)(b); --i)
#define FOREACH(i,C) for(__typeof(C.begin()) i=C.begin(); i!=C.end(); ++i)

const int max_n = 2000;
const double eps = 0.0000001;
const double pihalf = M_PI*0.5;
const double twopi = M_PI*2.0;

struct xy { int x, y; };

xy pts[max_n];

inline int dist2(const xy &a, const xy &b) {
	return (a.x-b.x)*(a.x-b.x) + (a.y-b.y)*(a.y-b.y);
}

struct rec { double f; int x; };

rec array[max_n];

inline bool operator<(const rec &a, const rec &b) {
	return a.f < b.f;
}

bool testcase() {
	int n, r;
	scanf("%d%d", &n, &r);
	if (!n) return false;
	int d = 2*r;
	int d2 = d*d;//d2eps = d2 + eps;
	FOR(i,0,n) scanf("%d%d", &pts[i].x, &pts[i].y);
	int res = 1;
	FOR(cur,0,n) {
		int cnt = 0;
		int curd;
		int cur_res = 1;
		FOR(i,0,n) if (i != cur && (curd = dist2(pts[i], pts[cur])) <= d2) {
			double f = atan2((double)(pts[i].y-pts[cur].y), (double)(pts[i].x-pts[cur].x));
			double dcurd = curd;
			double g = (dcurd < (double)d2-eps) ? acos(sqrt(dcurd) / d) : 0.0;
			double f1 = f-g, f2 = f+g;
			if (f1 < 0.0) f1 += twopi;
			else if (f1 >= twopi) f1 -= twopi;
			if (f2 < 0.0) f2 += twopi;
			else if (f2 >= twopi) f2 -= twopi;
			array[cnt].f = f1;
			array[cnt].x = 1;
			array[cnt+1].f = f2;
			array[cnt+1].x = -1;
			cnt += 2;
			if (f1 > f2) ++cur_res;
		}
		sort(array, array+cnt);
		FOR(i,0,cnt) {
			cur_res += array[i].x;
			res = max(res, cur_res);
		}
	}
	printf("It is possible to cover %d points.\n", res);
	return true;
}

int main() {
	while(testcase());
	return 0;
}
