#include <stdio.h>
#include <utility>
#include <map>

using namespace std;

#define FOREACH(it,t) for(__typeof(t.begin()) it=t.begin(); it!=t.end();it++)
#define FOR(q,n) for(int q=0;q<n;q++)
#define MAX 17
#define MAXX (1<<17)
#define INF 100000000
int r,c;

typedef pair<int,int> PII;
#define mp make_pair
#define fi first
#define se second

char s[2*MAX];
int data[MAX];
int comb;

int init(){
    scanf("%d %d",&r,&c);
    if (r==0 && c==0) return 0;
    FOR(q,r) {
        scanf("%s",s);
        int t=0;
        FOR(w,c) t=t*2+(s[w]=='X');
        data[q]=t;
    }

    comb=(1<<c);
    return 1;
}

   map<PII,int> best[2];
    int xxor[MAXX];

int bbest;

void init__(int i,int vystup,int vystup2,int vystup3,int n){
 if (i==c) {
     if (vystup!=0) return;
     int d[MAX];
     FOR(q,r) d[q]=data[q];
     d[0]=0;
     d[1]^=vystup2;
     d[2]^=vystup3;

            int cnt=n;
     for (int t=1;t<r-1;t++) {
            int mask=1;
            FOR(w,c) {
                if (d[t]&mask) {
                    d[t]^=mask;
                    d[t+1]^=xxor[mask];
                    d[t+2]^=mask;
//                    res^=xxor[mask];
//                    res2^=mask;
                    cnt+=1;
                }
                mask*=2;
            }


     }


        if (d[r-1]==0) bbest<?=cnt;



     return; 
 }
 init__(i+1,vystup,vystup2,vystup3,n);
 init__(i+1,vystup^xxor[1<<i],vystup2^(1<<i),vystup3,n+1);
 init__(i+1,vystup^(1<<i),vystup2^xxor[1<<i],vystup3^(1<<i),n+1);
}


int getbestone(int i,int vystup,int n){
if (i==c) {
    if (vystup!=0) return INF;
    return n;
}

int pp=INF;
pp<?=getbestone(i+1,vystup,n);
pp<?=getbestone(i+1,vystup^xxor[1<<i],n+1);
return pp;


}

void solve(){
    int act=0;
    int noact=1;

    {int mask=1;
        FOR(q,MAXX) xxor[q]=0;
        FOR(q,c) {
            if (q<c-1) xxor[1<<q]=(mask/2)+(mask*2)+mask;
            else xxor[1<<q]=(mask/2)+mask;
//            printf("xxor %d %d \n",1<<q,xxor[1<<q]);
            mask*=2;
        }

    }


    best[0].clear();
    //FOR(q,comb) best[0][q]=INF; // vieme to dosiahnut na 0
    bbest=INF;
    init__(0,data[0],0,0,1);

/*    FOR(t,r-1) if (t) {
        best[noact].clear();
        FOREACH(it,best[act]) // ideme spracovat riadok t,kombinaciu q
        { // chceme ho dat q-> data[t]
            int res=it->fi.se;
            int res0=res;
            int mask=1;
            int cnt=0;
            int q=it->fi.fi;
            int res2=0;
            FOR(w,c) {
                if ((data[t]^q)&mask) {
                    res^=xxor[mask];
                    res2^=mask;
                    cnt+=1;
                }
                mask*=2;
            }

            PII t=mp(res,res2);;
           if ( best[noact][t]>it->se+cnt || best[noact][t]==0)
                   best[noact][t]=it->se+cnt;
        }

//        FOR(q,comb) printf("%d ",best[noact][q]);
//        printf("\n");
//        act^=1;
//        noact^=1;
//    }
  */
    int min=bbest;
//    FOR(q,comb) if (min>best[act][mp(data[r-1],q)] &&
//               best[act][mp(data[r-1],q)]!=0)
//          min=best[act][mp(data[r-1],q)];

    if (r==1) {
        min=getbestone(0,data[0],1);

    }
    if (min==INF) printf("Damaged billboard.\n"); else
    printf("You have to tap %d tiles.\n",min-1);


}

int main(){
    while (init()) solve();


}
