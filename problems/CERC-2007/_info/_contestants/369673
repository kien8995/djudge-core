#include<cstdio>
#include<cstdlib>
#include<string>
#include<cstring>
#include<vector>
#include<cmath>
#include<cctype>
#include<queue>
#include<algorithm>
#include<set>
#include<map>
#include <list>
#include<numeric>

using namespace std;

#define FOR(i, a, b) for(int i=(a); i<=(b); i++)
#define FORD(i, a, b) for(int i=(a); i>=(b); i--)
#define REP(i, n) for(int i=0; i<(n); i++)
#define ALL(x) (x).begin(), (x).end()
#define MP make_pair
#define PB push_back
#define F first
#define S second
#define FI first
#define SE second
#define FORE(i, c) for(__typeof((c).begin()) i = (c).begin(); i!=(c).end(); ++i)
#define SIZE(x) ((int)(x).size())

typedef vector<int> VI;
typedef long long ll;
typedef pair<int, int> PII;

#define MAX_N 2500
#define INFTY 100000000

struct kraw
{
    int v1,v2,w,c;
    int n,wh;
};

int n,m,ost;
vector<kraw> t[MAX_N];
int d[MAX_N];
kraw par[MAX_N];

char ss[MAX_N]; 
int kk;


#define M 2500

vector<PII> v[M];

void add_edge(int v1,int v2,int w,int c)
{
    w=(v1<kk && ss[v1]=='.');
//    printf("%d %d %d %d\n",v1,v2,w,c);
    v[v1].PB(MP(v2,w));
  /*  kraw e1;
    e1.v1=v1; e1.v2=v2; e1.w=w; e1.c=c;
    t[v1].PB(e1);
    t[v1].back().n=-1;
    t[v1].back().wh=SIZE(t[v1])-1;*/
}

void Bellman_Ford(int pocz,int kon)
{
    bool rel[MAX_N];
    REP(i,n) {d[i]=INFTY; par[i].v1=-1; rel[i]=false; }
    d[pocz]=0; rel[pocz]=true;
    bool dorel=true;
    while(dorel && d[kon]>ost)
    {
	dorel=false;
	REP(i,n) if(rel[i])
	{
	    REP(j,SIZE(t[i])) if(t[i][j].c && d[t[i][j].v2]>d[i]+t[i][j].w)
	    {
		rel[t[i][j].v2]=true;
		dorel=true;
		d[t[i][j].v2]=d[i]+t[i][j].w;
		par[t[i][j].v2]=t[i][j];
	    }
	    rel[i]=false;
	}
    }
}

int transform(int pocz,int kon)
{
    kraw e1;
    int v=kon,mi=INFTY;
    while(v!=pocz)
    {
	mi=min(mi,par[v].c);
	v=par[v].v1;
    }
    v=kon;
    while(v!=pocz)
    {
	kraw &e=par[v];
	t[e.v1][e.wh].c-=mi;
	if(e.n!=-1) t[e.v2][e.n].c+=mi;
	else
	{
	    e1.v1=e.v2; e1.v2=e.v1; e1.w=-e.w; e1.c=mi;
	    e1.wh=SIZE(t[e1.v1]); e1.n=e.wh;
	    e.n=e1.wh;
	    t[e1.v1].PB(e1);
	}
	v=e.v1;
    }
    return mi;
}

int Busacker_Gowen(int pocz,int kon)
{
    bool poss=true;
    int wyn=0;
    ost=-1000000000;
    while(poss)
    {
	Bellman_Ford(pocz,kon);
	if(par[kon].v1==-1) poss=false;
	else
	{
    wyn+=transform(pocz,kon)*d[kon];
	    ost=d[kon];
	}
    }
    return wyn;
}

#define inf 1000000

int num[M][M],od[M][M];
char s[13];

list<int > q;
int A,B,C,D;

int wynik(int n)
{
    REP(pocz,n) 
    {
	REP(i,n) od[pocz][i]=inf;
	od[pocz][pocz]=0;
	q.clear();
	q.push_back(pocz);
	while(!q.empty())
	{
	    int x=q.front();
	    q.pop_front();
	    FORE(a,v[x]) if(od[pocz][a->F]>od[pocz][x]+(a->S))
	    {
		od[pocz][a->F]=od[pocz][x]+(a->S);
		if(a->S) q.push_back(a->F);
		else q.push_front(a->F);
	    }
	}
    }
//    REP(i,n) { REP(j,n) printf("%d ",od[i][j]); printf("\n");}
    int ret=inf;
    REP(i,n) 
    {
	ret<?=od[A][i]+od[B][i]+od[C][i]+1+min(od[D][A],min(od[D][B],od[D][C]));
	ret<?=od[A][i]+od[D][i]+od[C][i]+1+min(od[B][A],min(od[B][D],od[B][C]));
	ret<?=od[A][i]+od[B][i]+od[D][i]+1+min(od[C][A],min(od[C][B],od[C][D]));
	ret<?=od[D][i]+od[B][i]+od[C][i]+1+min(od[A][D],min(od[A][B],od[A][C]));
    }
    ret<?=od[A][B]+od[A][C]+od[A][D]+od[A][A];
    ret<?=od[B][B]+od[B][C]+od[B][D]+od[B][A];
    ret<?=od[C][B]+od[C][C]+od[C][D]+od[C][A];
    ret<?=od[D][B]+od[D][C]+od[D][D]+od[D][A];
    int p[4]={A,B,C,D};
    sort(p,p+4);
    do
    {
	int x=0;
	REP(i,3) x+=od[p[i]][p[i+1]];
//	if(x<5 )printf("tu %d\n",x);
	ret<?=x;
    }
	while(next_permutation(p,p+4));
    REP(i,n) REP(j,n)
    {
	REP(k,4) FOR(l,k+1,3) REP(u,4) if(k!=u && l!=u)
	{
	    int x=0;
	    x=od[i][j]+1+od[p[k]][i]+od[p[l]][i]+od[p[u]][j]+od[p[6-k-l-u]][j];
//	    if(x<5 )printf("tutaj %d\n",x);
	    ret<?=x;
	    break;
	}
    }
    return ret;
}

int main()
{
    int h;
    while(scanf("%d",&h) && h)
    {
	ost=m=n=0;
	REP(i,MAX_N) t[i].clear();
	int k=0;
	FOR(i,h,2*h-1){ REP(j,i) 
	{
	    num[i-h][j]=k;
	    scanf("%s",s);
	    kk=k+1;
	    ss[k]=s[0];
	//    printf("%c (%d)\n",s[0],k);
	    if(s[0]=='A') A=k;
	    if(s[0]=='B') B=k;
	    if(s[0]=='C') C=k;
	    if(s[0]=='D') D=k;
	    if(j) 
	    {
		add_edge(k,num[i-h][j-1],0,inf);
		add_edge(num[i-h][j-1],k,0,inf);
	    } 
	    if(i>h && j) 
	    {
		add_edge(k,num[i-h-1][j-1],0,inf);
		add_edge(num[i-h-1][j-1],k,0,inf);
	    }
	    if(i>h && j<i-1) 
	    {
		add_edge(k,num[i-h-1][j],0,inf);
		add_edge(num[i-h-1][j],k,0,inf);
	    }
	    k++;
	} //printf("\n");
	}
	FORD(i,2*h-2,h) { REP(j,i) 
	{
	    num[3*h-2-i][j]=k;
	    scanf("%s",s);
	    kk=k+1;
	    ss[k]=s[0];
	   // printf("%c (%d)\n",s[0],k);
	    if(s[0]=='A') A=k;
	    if(s[0]=='B') B=k;
	    if(s[0]=='C') C=k;
	    if(s[0]=='D') D=k;
	    if(j) 
	    {
		add_edge(k,num[3*h-2-i][j-1],0,inf);
		add_edge(num[3*h-2-i][j-1],k,0,inf);
	    } 
	    if(1) 
	    {
		add_edge(k,num[3*h-2-i-1][j+1],0,inf);
		add_edge(num[3*h-2-i-1][j+1],k,0,inf);
	    }
	    if(1) 
	    {
		add_edge(k,num[3*h-2-i-1][j],0,inf);
		add_edge(num[3*h-2-i-1][j],k,0,inf);
	    }
	    k++;
	} //printf("\n");
	}
	printf("You have to buy %d parcels.\n",wynik(k));
    }
    return 0;
}
