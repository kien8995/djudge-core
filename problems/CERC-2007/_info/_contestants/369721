#include <cstdio>
#include <algorithm>
#include <list>
#include <set>
#include <cmath>
#include <queue>
using namespace std;
#define double float

#define REP(i,n) for(int i = 0; i < (n); ++i)
#define FOR(i,a,b) for(int i = (a); i <= (b); ++i)
#define FORD(i,a,b) for(int i = (a); i >= (b); --i)
#define PRINTF(args...) printf(args)
// #define PRINTF(args...)


struct punkt
{
  double x,y;
  punkt(){}
  punkt(double xx, double yy): x(xx), y(yy){}
  int dist(const punkt& co)
  {
	return (x-co.x)*(x-co.x) + (y-co.y)*(y-co.y);
  }
  double norm() const { return x*x+y*y; }
  punkt r90() { return punkt(-y, x); }
};

inline punkt operator-(const punkt &a, const punkt &b) { return punkt(a.x-b.x, a.y-b.y); }
inline punkt operator+(const punkt &a, const punkt &b) { return punkt(a.x+b.x, a.y+b.y); }
inline punkt operator*(const punkt &a, double f) { return punkt(a.x*f, a.y*f); }
inline punkt operator/(const punkt &a, double f) { return punkt(a.x/f, a.y/f); }


const int maxn=2101;

punkt T[maxn];
int ziomy[maxn][maxn];
int cnts[maxn];
double R;

// znajdze 2 okresgi o promienniu R wyznaczone przez A,B
inline void find_kolo(const punkt & A, const punkt & B, punkt wynik[])
{
  double r1 = R, r2 = R;
  // R
  punkt d(B-A);
  double dist = d.norm();
  r1 *= r1/dist;
  r2 *= r2/dist;
  double a = (r1-r2+1)*0.5;
  punkt p = A + d*a, offset = d.r90()*sqrt(r1 - a*a);
  //printf("Aaaaaa: %lf %lf\n", p.x, p.y, offset.x, offset.y);
  wynik[0] = p+offset;
  wynik[1] = p-offset;
}

int main()
{
  int n,r;
  while (true)
  {
	scanf("%d%d", &n, &r);
	R=r+0.00005;
	if (n==0 && r==0) break;
	
	for (int i=0; i<n; i++)
	{
	  int x, y;
	  cnts[i] = 0;	
	  scanf("%d%d", &x, &y);
	  T[i]=punkt(x,y);
	}
	
	double RR4 = 4*R*R;
	double RRe = (R+0.00005)*(R+0.00005);
	for (register int i=0; i<n; i++)
	{
	  for (register int j=i+1; j<n; j++)
	  {
		if (RR4 > T[i].dist(T[j]))
		  ziomy[i][cnts[i]++] = j;
	  }
	}
	
	punkt t[2];	
	int best = 0;
	for (register int i=0; i<n; i++)
	{
	  for (register int j=0; j<cnts[i]; j++)
	  {
		int k = ziomy[i][j];
		if (i==k) continue;
		find_kolo(T[i], T[k], t);
		//printf("R: %lf", R);
		//printf("(%lf %lf), (%lf %lf)\n", T[i].x, T[i].y, T[k].x, T[k].y);		
		//printf("(%lf %lf), (%lf %lf)\n", t[0].x, t[0].y, t[1].x, t[1].y);
		for (register int x=0; x<2; x++)
		{
		  int akt = 0;
		  for (register int m=0; m<cnts[i]; m++)
			if (t[x].dist(T[ziomy[i][m]]) < RRe) ++ akt;
		  best >?= akt;
		  if (best == 3) goto poza;
		}
	  }
	}
	poza:;
	printf("It is possible to cover %d points.\n", best+1);
  }
  return 0;
}
