#include <cstdio>
#include <cstdlib>
#include <vector>
#include <algorithm>
#include <cmath>
using namespace std;
#define REP(i,n)	for(int i=0,_n=(n);i<_n;++i)
#define REPD(i,n)	for(int i=(n-1);i>=0;--i)
#define FOR(i,s,k)	for(int i=(s),_k=(k);i<=_k;++i)
#define FORD(i,s,k)	for(int i=(s),_k=(k);i>=_k;--i)
#define FORE(it,q)	for(__typeof((q).begin())it=(q).begin();it!=(q).end();++it)
#define FORED(it,q)	for(__typeof((q).rbegin())it=(q).rbegin();it!=(q).rend();++it)
#define FOREACH(it,f,l)	for(__typeof(f)it=f;it!=l;++it)
#define FOREACHD(it,f,l)	for(__typeof(f)it=l;it--!=f;)

int x[1010],y[1010],val[1010];

bool cmpx(int a, int b) {
	if(x[a]==x[b]) return y[a] < y[b];
	return x[a]<x[b];
}
bool cmpy(int a, int b) {
	if(y[a]==y[b]) return x[a] < x[b];
	return y[a] < y[b];
}

vector<int> g[1010];

// a --> b
char dir(int a, int b) {
	if(x[a]==x[b] && y[b] < y[a]) return 'S';
	if(x[a]==x[b] && y[b] > y[a]) return 'N';
	if(x[a] < x[b]) return 'E';
	return 'W';
}


int S[1010],ile=0,n;

int pole() {
	long long res = 0;
	FOR(i,0,n-2)  {
		res += x[S[i]]*1ll*y[S[i+1]];
	}
	FOR(i,1,n-1) res -= x[S[i]]*1ll*y[S[i-1]];
	res += x[S[n-1]]*y[S[0]] - x[S[0]]*y[S[n-1]];
	return res>0;
}


bool testcase() {
	scanf("%d",&n);
	if(n==0) return 0;
	REP(i,n) { scanf("%d%d",x+i,y+i); val[i]=i; }
	REP(i,n) g[i].clear();
	sort(val,val+n,cmpx);
	FOR(i,1,n-1) {
		if(x[val[i-1]]==x[val[i]]) {
			g[val[i]].push_back(val[i-1]);
			g[val[i-1]].push_back(val[i]);
			++i;
		}
	}
//	printf("sortX: ");
//	REP(i,n) printf("%d ", val[i]);
//	printf("\n");

	sort(val,val+n,cmpy);
	FOR(i,1,n-1) {
		if(y[val[i-1]]==y[val[i]]) {
			g[val[i]].push_back(val[i-1]);
			g[val[i-1]].push_back(val[i]);
			++i;
		}
	}

//	printf("sortY: ");
//	REP(i,n) printf("%d ", val[i]);
//	printf("\n");
//	REP(i,n) printf("%d: %d %d\n", i, g[i][0], g[i][1]);

	ile = 0;
	S[ile++] = 0;
	S[ile++] = g[0][0];
	while(ile<n) {
		int k = S[ile-1];
		int l = S[ile-2];
		if(l == g[k][0]) {
			S[ile++] = g[k][1];
		} else {
			S[ile++] = g[k][0];
		}
	}

//	REP(i,ile) printf("%d ", S[i]);
//	printf("\n");

//	REP(i,n) printf("%d: %d %d\n", i, x[i],y[i]);

	if(pole()>0) {
		printf("%c", dir(S[0],S[ile-1]));
		REP(i,ile-1) {
//		printf("dir(%d,%d) = ", S[ile-1-i], S[ile-2-i]);
		printf("%c", dir(S[ile-1-i],S[ile-2-i]));
		}
		printf("\n");
	} else {
		REP(i,ile-1) printf("%c", dir(S[i],S[i+1]));
		printf("%c\n", dir(S[ile-1],S[0]));
	}

	return 1;
}


int main() {
	while(testcase());
	return 0;
}

