//#include<cstdio>
//#include<cstdlib>
//#include<cstring>
//#include<climits>
#include<cmath>
#include<iostream>
#include<string>
#include<stack>
#include<algorithm>

using namespace std;

#define PRINTF(args...) printf(args)
//#define PRINTF(args...) 

#define FOR(i,a,b) for(int i=(a); i<(int)(b); ++i)
#define FORD(i,a,b) for(int i=(a)-1; i>=(int)(b); --i)
#define FOREACH(i,C) for(__typeof(C.begin()) i=C.begin(); i!=C.end(); ++i)

const double step = 0.0002;

inline double cone(double r1, double r2) {
	return step*(r1*r1 + r1*r2 + r2*r2);
}

struct myexp {
	virtual double eval(double x) = 0;
	virtual bool var() = 0;
	virtual ~myexp() {}
};

void main_part(double B, double H, myexp *R, myexp *T) {
	double V1 = 0.0, V2a = 0.0, V2b = 0.0;
	{
		bool up = false;
		double last = R->eval(0), last2 = -1.0;
		double cur = step;
		for (;;) {
			if (cur > H+0.5*step) break;
			if (cur >= B-0.5*step) up = true;
			double next = R->eval(cur);
			V1 += cone(last,next);
			last = next;
			if (up) {
				double next2 = T->eval(cur);
				if (last2 > -0.5) V1 -= cone(last2, next2);
				last2 = next2;
			}
		}
	}
	V1 *= 2.5*0.5;
	{
		bool up = false;
		double last = R->eval(0), last2 = -1.0;
		double cur = step;
		for (;;) {
			if (cur > H+0.5*step) break;
			if (cur >= B-0.5*step) up = true;
			double next = R->eval(cur);
			V2a += cone(last,next);
			last = next;
			if (up) {
				double next2 = T->eval(cur);
				if (last2 > -0.5) {
					double c = cone(last2, next2);
					V2a -= c;
					V2b += c;
				}
				last2 = next2;
			}
			if (V2a+V2b >= V1) {
				printf("Pour %.3f litres / %.3f cm of water.\n", V2b*M_PI/3000.0,
				 cur >= B ? cur-B : 0.0);
				delete R; delete T;
				return;
			}
		}
	}
}

struct no_myexp:public myexp {
	double val;
	no_myexp(double v):val(v) {}
	
	double eval(double x) { return val; }
	bool var() { return false; }
};
struct var_myexp:public myexp {
	double eval(double x) { return x; }
	bool var() { return true; }
};
struct plus_myexp:public myexp {
	myexp *e1, *e2;
	plus_myexp(myexp *f1, myexp *f2):e1(f1), e2(f2) {}
	
	double eval(double x) {
		return e1->eval(x) + e2->eval(x);
	}
	bool var() { return true; }
	~plus_myexp() { delete e1; delete e2; }
};
struct minus_myexp:public myexp {
	myexp *e1, *e2;
	minus_myexp(myexp *f1, myexp *f2):e1(f1), e2(f2) {}
	
	double eval(double x) {
		return e1->eval(x) - e2->eval(x);
	}
	bool var() { return true; }
	~minus_myexp() { delete e1; delete e2; }
};
struct mul_myexp:public myexp {
	myexp *e1, *e2;
	mul_myexp(myexp *f1, myexp *f2):e1(f1), e2(f2) {}
	
	double eval(double x) {
		return e1->eval(x) * e2->eval(x);
	}
	bool var() { return true; }
	~mul_myexp() { delete e1; delete e2; }
};
struct div_myexp:public myexp {
	myexp *e1, *e2;
	div_myexp(myexp *f1, myexp *f2):e1(f1), e2(f2) {}
	
	double eval(double x) {
		return e1->eval(x) / e2->eval(x);
	}
	bool var() { return true; }
	~div_myexp() { delete e1; delete e2; }
};

struct oper_base {
	virtual myexp *trans(myexp *e1, myexp *e2) = 0;
};

template<class oper_myexp>
struct oper:public oper_base {
	myexp *trans(myexp *e1, myexp *e2) {
		if (e1->var() || e2->var()) return new oper_myexp(e1, e2);
		else return new no_myexp(oper_myexp(e1, e2).eval(0.0));
	}
};

struct oper_rec {
	int p;
	oper_base *o;
	
	oper_rec(int pi, oper_base *oi):p(pi), o(oi) {}
};

inline void do_oper(stack<oper_rec> &opers, stack<myexp *> &exps) {
	myexp *e2 = exps.top(); exps.pop();
	myexp *e1 = exps.top(); exps.pop();
	exps.push(opers.top().o->trans(e1, e2));
	delete opers.top().o;
	opers.pop();
}

inline void do_pop(stack<oper_rec> &opers, stack<myexp *> &exps, int p) {
	while (!opers.empty() && p <= opers.top().p) {
		do_oper(opers, exps);
		opers.pop();
	}
}

myexp *parse(const string str) {
	int len = str.length();
	bool is_number = false, is_dot;
	double cur_number, cur_dot;
	stack<oper_rec> opers;
	stack<myexp *> exps;
	FOR(i,0,len) {
		char c = str[i];
		if (c >= '0' && c <= '9') {
			if (!is_number) {
				cur_number = c-'0';
				is_number = true;
				is_dot = false;
			}
			else if (is_dot) {
				cur_number += (c-'0')*cur_dot;
				cur_dot *= 0.1;
			}
			else cur_number = 10.0*cur_number + (c-'0');
			continue;
		}
		if (c == '.') {
			if (!is_number) {
				cur_number = 0.0;
				is_number = true;
			}
			cur_dot = 0.1;
			is_dot = true;
			continue;
		}
		if (is_number) {
			exps.push(new no_myexp(cur_number));
			is_number = false;
		}
		else if (c == 'x') {
			exps.push(new var_myexp());
		}
		else if (c == '(') {
			opers.push(oper_rec(1, 0));
		}
		else if (c == '+') {
			do_pop(opers, exps, 2);
			opers.push(oper_rec(2, new oper<plus_myexp>()));
		}
		else if (c == '-') {
			do_pop(opers, exps, 2);
			opers.push(oper_rec(2, new oper<minus_myexp>()));
		}
		else if (c == '*') {
			do_pop(opers, exps, 3);
			opers.push(oper_rec(3, new oper<mul_myexp>()));
		}
		else if (c == '/') {
			do_pop(opers, exps, 3);
			opers.push(oper_rec(3, new oper<div_myexp>()));
		}
	}
}

bool testcase() {
	double B, H;
	cin >> B >> H;
	if (B == 0.0) return false;
	string str;
	cin >> str;
	myexp *R = parse(str);
	cin >> str;
	myexp *T = parse(str);
	main_part(B, H, R, T);
	return true;
}

int main() {
	while(testcase());
	return 0;
}
