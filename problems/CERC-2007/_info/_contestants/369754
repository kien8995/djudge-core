#include <cstdio>
#include <cstdlib>
#include <vector>
#include <algorithm>
#include <cmath>
#include <list>
using namespace std;
#define REP(i,n)	for(int i=0,_n=(n);i<_n;++i)
#define REPD(i,n)	for(int i=(n-1);i>=0;--i)
#define FOR(i,s,k)	for(int i=(s),_k=(k);i<=_k;++i)
#define FORD(i,s,k)	for(int i=(s),_k=(k);i>=_k;--i)
#define FORE(it,q)	for(__typeof((q).begin())it=(q).begin();it!=(q).end();++it)
#define FORED(it,q)	for(__typeof((q).rbegin())it=(q).rbegin();it!=(q).rend();++it)
#define FOREACH(it,f,l)	for(__typeof(f)it=f;it!=l;++it)
#define FOREACHD(it,f,l)	for(__typeof(f)it=l;it--!=f;)
#include <queue>

char a[300][300];
int b[300][300];
int size[300];
int R;
char bramka[10000];
struct edge {
	int b1, b2,neg;
	edge(int _b1, int _b2, int _neg ) : b1(_b1) , b2(_b2), neg(_neg) {}
};
int in[10000];
list<edge> adj[10000];
int neg;

int ile[2][10000];


bool cmp(const edge& a, const edge& b ) {
	if(a.b1 == b.b1) return a.b2 < b.b2;
	return a.b1 < b.b1;
}



int val(int b) {
	if(b<=1) return b;
	if(bramka[b] == '&') return ile[0][b]==0;
	if(bramka[b] == '1') return ile[1][b]>=1;
	if(bramka[b] == '=') return ile[1][b]%2==1;
	printf("Blad w val!!\n");
}

// c == 0
// c == 1 // negated val bramka
// c == 2 // not negated val bramka
void idz(int y, int x, int ly, int lx, int val) {
	if(y < 0 || x < 0 || y >= R || x >= size[y]) return;
	//printf("idz(%d,%d,%d,%d,%d)\n", y,x,ly,lx,val);
	if(a[y][x]=='-') {
		if(lx < x) idz(y,x+1,ly,lx,val);
		else idz(y,x-1,y,x,val);
	} else 
	if(a[y][x]=='|') {
		if(ly < y) idz(y+1,x,y,x,val);
		else idz(y-1,x,y,x,val);
	} else 
	if(a[y][x]=='+') {
		// y-1,x
		if(y-1 > 0 && (y-1 != ly || x != lx) && (a[y-1][x]=='|')) 
			idz(y-1,x,y,x,val);
		if(y+1 < R && (y+1 != ly || x != lx) && (a[y+1][x]=='|')) 
			idz(y+1,x,y,x,val);
		if(x-1 > 0 && (x-1 != lx || y != ly) && (a[y][x-1]=='-'))
			idz(y,x-1,y,x,val);
		if(x+1 < size[y] && (x+1 != lx || y != ly) && (a[y][x+1]=='-' || a[y][x+1]=='='))
			idz(y,x+1,y,x,val);
	} else
	if(a[y][x]=='x') {
		if(lx == x) {
			if(ly < y) idz(y+1,x,y,x,val);
			else idz(y-1,x,y,x,val);
		} else { // ly == y
			if(lx < x) idz(y,x+1,y,x,val);
			else idz(y,x-1,y,x,val);
		}
	} else
	if(a[y][x]=='=') {
		idz(y,x+1,y,x,val);
	} else
	if(a[y][x] >= 'A' && a[y][x] <= 'Z') {
		adj[val].push_back(edge(val,-a[y][x],neg));
//		edges.push_back(edge(val,-a[y][x]));
	} else
	if(a[y][x]=='#') {
		adj[val].push_back(edge(val,b[y][x],neg));
//		edges.push_back(edge(val,b[y][x]));
		++in[b[y][x]];
	}
}


bool testcase() {
	R=0;
	while(1) {
		gets(a[R++]);
		if(a[R-1][0]=='*') break;
	}
	if(R==1) return 0;

	REP(i,R) size[i]= strlen(a[i]);
	REP(i,R) REP(j,size[i]) b[i][j]=-1;

	int ilehash=1;
	REP(i,R) {
		REP(j,size[i]) {
			if(a[i][j]=='#') {
				if(i>0 && b[i-1][j]>=0) {
					b[i][j]=b[i-1][j];
				} else
				if(j>0 && b[i][j-1]>=0) {
					b[i][j]=b[i][j-1];
				} else b[i][j]=++ilehash;

				if(i>0 && j > 0) {
					if(a[i-1][j]=='#' && a[i][j-1]=='#') {
						if(a[i][j]=='&' || a[i][j]=='=' || a[i][j]=='1') {
							bramka[b[i][j]] = a[i][j];
						}
						a[i][j]='#';
					}
				}
			}
		}
	}

	FOR(i,0,ilehash+5) { ile[0][i]=ile[1][i]=in[i]=0; }

	REP(i,R) {
		REP(j,size[i]-2) { // uwaga!!1
			neg = 0;
			if(a[i][j]=='0' && a[i][j+1]=='=') {
				idz(i,j+2,i,j+1,0);
			} else
			if(a[i][j]=='1' && a[i][j+1]=='=') {
				idz(i,j+2,i,j+1,1);
			} else
			if(a[i][j]=='#' && a[i][j+1]=='o' && a[i][j+2]=='=') {
				neg = 1;
				idz(i,j+3,i,j+2,b[i][j]);
			} else
			if(a[i][j]=='#' && a[i][j+1]=='=') {
				idz(i,j+2,i,j+1,b[i][j]);
			}
		}
	}


	
	queue<int> q;
	q.push(0);
	q.push(1);

	int odp[50];
	REP(i,50) odp[i]=-1;
	while(!q.empty()) {
		int x = q.front();
		q.pop();
		FORE(it,adj[x]) {
			if(it->b2 > 0) {
				if(it->neg) ++ile[!val(it->b1)][it->b2];
				else ++ile[val(it->b1)][it->b2];
				if(--in[it->b2] == 0) q.push(it->b2);
			} else {
				if(it->neg) odp[-it->b2 - 'A'] = !val(it->b1);
				else odp[-it->b2 - 'A'] = val(it->b1);
			}
		}
	}
	FOR(i,0,ilehash) adj[i].clear();

	REP(i,30) if(odp[i]>=0) printf("%c=%d\n", 'A'+i, odp[i]);
	printf("\n");

	return 1;
}


int main() {
	while(testcase());
	return 0;
}

