#include <cstdio>
#include <list>
#include <algorithm>
#include <vector>

using namespace std;

const int maxn=1000+5;
const int maxk=20000+5;

struct Pont {
	int id, r, c, hols, holo;
	Pont(int id=-1, int r=-1, int c=-1): id(id), r(r), c(c) {
	}
};


int n;

Pont *pontok;
list<int> *tmps, *tmpo;
vector<int> *sor, *oszlop;
char ki[maxn];


class SortOszlop {
	public:
		bool operator () (const int a, const int b)  const {
			return pontok[a].r < pontok[b].r;
			}
};

class SortSor {
	public:
		bool operator () (const int a, const int b)  const {
			return pontok[a].c < pontok[b].c;
			}
};


int beolvas() {
	int i, a, b;
	
	for(i=0; i<maxk; i++) {
		tmps[i].clear();
		tmpo[i].clear();
	}
	
	scanf("%d", &n);
	if(!n)
		return n;
	
	for(i=0; i<n; i++)
	{	
		scanf("%d %d", &a, &b);
		a+=10000;
		b+=10000;
		pontok[i]=Pont(i, b, a);
		
		tmpo[a].push_back(i);
		tmps[b].push_back(i);
	}
	
	for(i=0; i<maxk; i++) {
		int m;
		list<int>::iterator it;
		
		m=tmpo[i].size();
		oszlop[i].clear();
		oszlop[i].reserve(m);
		
		for(it=tmpo[i].begin(); it!=tmpo[i].end(); it++)
				oszlop[i].push_back(*it);
		
		sort(oszlop[i].begin(), oszlop[i].end(), SortOszlop());

		m=tmps[i].size();
		sor[i].clear();
		sor[i].reserve(m);
		
		for(it=tmps[i].begin(); it!=tmps[i].end(); it++)
				sor[i].push_back(*it);
		
		sort(sor[i].begin(), sor[i].end(), SortSor());
		}
	
	return 1;
}


int main() {
	tmps=new list<int>[maxk];
	tmpo=new list<int>[maxk];
	sor=new vector<int>[maxk];
	oszlop=new vector<int>[maxk];
	pontok=new Pont[maxn];
	
	while(beolvas()) {
		int i, j, m, sorbol;
		
		for(i=0; i<maxk; i++) {
			m=sor[i].size();
			for(j=0; j<m; j++) {
				pontok[sor[i][j]].hols=j;
				//printf("%d (%d, %d) pont a %d. sorban az %d.\n", sor[i][j], pontok[sor[i][j]].c, pontok[sor[i][j]].r, i, j);
			}
		}
		
		for(i=0; i<maxk; i++) {
			m=oszlop[i].size();
			for(j=0; j<m; j++) {
				pontok[oszlop[i][j]].holo=j;
				//printf("%d pont a %d. osylopban az %d.\n", oszlop[i][j], i, j);
				
			}
		}
		
		sorbol=0;
		i=0;
		for(j=0; j<n; j++) {
			//printf("Vizsgalt: %d\n", i);
			if(sorbol) {
				if(pontok[i].hols & 1) {
					ki[j]='W';
					i=sor[pontok[i].r][pontok[i].hols-1];
				}
				else {
					ki[j]='E';
					i=sor[pontok[i].r][pontok[i].hols+1];
				}
			}
			else {
				if(pontok[i].holo & 1) {
					ki[j]='S';
					i=oszlop[pontok[i].c][pontok[i].holo-1];
				}
				else {
					ki[j]='N';
					i=oszlop[pontok[i].c][pontok[i].holo+1];
				}
			}
			
			sorbol=1-sorbol;
		}
		
		int s=0;
		for(j=0; j < n-1; j++) {
			int a=ki[j], b=ki[j+1];
			
			if(a=='N' && b=='E')
				s+=1;
			if(a=='N' && b=='W')
				s+=-1;
			
			if(a=='S' && b=='E')
				s+=-1;

			if(a=='S' && b=='W')
				s+=1;

			a=ki[j+1];
			b=ki[j];
			if(a=='N' && b=='E')
				s+=-1;
			if(a=='N' && b=='W')
				s+=1;
			
			if(a=='S' && b=='E')
				s+=1;

			if(a=='S' && b=='W')
				s+=-1;
			
		}
	
	ki[n]=0;
		//printf("szog %d n %d\n", s, n);
	if(s>=0)
		printf("%s\n", ki);
	else {
		for(i=n-1; i>=0; i--) {
			switch(ki[i]) {
				case 'N':
					putchar('S');
					break;
				case 'S':
					putchar('N');
					break;
				case 'E':
					putchar('W');
					break;
				case 'W':
					putchar('E');
					break;
				default:
					break;
			}
		}
		
		printf("\n");
	}
		
	}
	
	delete [] pontok;
	delete [] tmps;
	delete [] tmpo;
	return 0;
}
