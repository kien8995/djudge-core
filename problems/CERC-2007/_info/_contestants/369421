#define NDEBUG

#include <cassert>
#include <cstdio>
#include <iostream>
#include <vector>
#include <algorithm>

using namespace std;

#ifndef NDEBUG
#define PV(var) std::cerr<<#var<<": "<<var<<"; ";
#define PN std::cerr<<std::endl;
#else
#define PV(...)
#define PN
#endif

int C, R;

int N;

struct Eq
{
	std::vector<int> v;
	int rhs;
	Eq()
		: v(R*C, 0)
	{}
	void xx(const Eq &e)
	{
		for(int i=0; i<(int)v.size(); ++i)
		{
			v[i]^=e.v[i];
		}
		rhs^=e.rhs;
	}
	bool empty() const
	{
		for(int i=0; i<(int)v.size(); ++i) if(v[i]) return false;
		return true;
	}
	void print()
	{
#ifndef NDEBUG
		for(int i=0; i<(int)v.size(); ++i)
			if(v[i]) cerr<<"("<<i/C<<","<<i%C<<")x";
		cerr<<rhs<<"\n";
#endif
	}
};

vector<Eq> tab;

int num(int x, int y)
{
	return y*C+x;
}

int main2()
{
	tab.resize(0);
	scanf("%d %d", &R, &C);
	if(R==0 && C==0) return 1;
	tab.resize(R*C, Eq());
	PV(R); PV(C); PN;
	for(int i=0; i<R; ++i)
	{
		scanf("%*[^X.]\n");
		for(int j=0; j<C; ++j)
		{
			char ch;
			tab[num(j, i)].v[num(j, i)]=1;
			if(j>0) tab[num(j, i)].v[num(j-1, i)]=1;
			if(i>0) tab[num(j, i)].v[num(j, i-1)]=1;
			if(i<R-1) tab[num(j, i)].v[num(j, i+1)]=1;
			if(j<C-1) tab[num(j, i)].v[num(j+1, i)]=1;
			scanf("%c", &ch);
			tab[num(j, i)].rhs=(ch=='X');
			PV(num(j, i));
			tab[num(j, i)].print();
		}
	}
	PV("FIRST\n");
	for(int i=0; i<R*C-1; ++i)
	{
		int j=i;
		while(j<R*C && tab[j].v[i]==0 ) j++;
		if(j==R*C)
		{
			//			PV("AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA\n");
			//			return 0;
		}
		else
		{
			if(j!=i) std::swap(tab[i], tab[j]);
			for(j=i+1; j<R*C; ++j)
			{
				if(tab[j].v[i])	tab[j].xx(tab[i]);
			}
		}
		PV(i);
		tab[i].print();
	}
	int result=R*C*100;
	for(int i=0; i<R*C; ++i)
		if(tab[i].empty() && tab[i].rhs) result=-1;
	if(R*C<2) printf("You have to tap %d tiles.\n", tab[0].rhs);
	else if(result<0) printf("Damaged billboard.\n");
	else
	{
		PV("SECOND\n");
		for(int ll=0; ll<2; ++ll)
		{
			vector<Eq> tab1(tab);
			if(tab1[R*C-2].empty()) tab1[R*C-2].rhs=ll;
			else ++ll;
			tab1[R*C-2].v[R*C-2]=1;
			for(int lll=0; lll<2; ++lll)
			{
				vector<Eq> tab2(tab1);
				if(tab2[R*C-1].empty()) tab2[R*C-1].rhs=lll;
				else ++lll;
				tab2[R*C-1].v[R*C-1]=1;
				for(int i=R*C-1; i>=0; --i)
				{
					int j=i;
					for(j=0; j<i; ++j)
					{
						if(tab2[j].v[i]) tab2[j].xx(tab2[i]);
					}
					PV(i);
					tab2[i].print();
				}
				int res=0;
				for(int i=0; i<R*C; ++i)
					if(tab2[i].rhs) res++;
				PV(res);
				result=std::min(result, res);
			}
		}
		for(int i=0; i<R*C; ++i)
		{
			PV(tab[i].rhs); PN;
		}
		PV(result);
		printf("You have to tap %d tiles.\n", result);
	}

	//return 1 if end of input
	return 0;
}

int main()
{
	int d=1000000000;
	//	scanf("%d",&d);
	while(d-- && !main2());
	return 0;
}
