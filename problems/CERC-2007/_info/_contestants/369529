#include <queue>

using std::queue;
class point3d{ public: 
	int x,y,z;
	inline void set(int nx, int ny, int nz){ x=nx; y=ny; z=nz; };
	inline point3d(){ set(0,0,0); }
	inline void keysit(int k){
		z |= k; 
	};
#ifdef DEB
	void print(char *s, char *endl="\n"){ printf("%s{%2d,%2d,%2d}%s",s,x,y,z,endl); };
#else
	inline void print(char *s, char *endl="\n"){};
#endif
};

point3d nextpoint(point3d p, int pcase){
	switch(pcase){
		case 0: p.set(p.x+1, p.y,   p.z); break;
		case 1: p.set(p.x-1, p.y,   p.z); break;
		case 2: p.set(p.x,   p.y+1, p.z); break;
		case 3: p.set(p.x,   p.y-1, p.z); break;
	};
	return p;
};

//Globals
char ***map; //map[z][y][x] in 3D :P
const int mapmaxl = 100 + 3 + 1;
int R,C;
const char MRK = ' '; // MaRKer
int Sx,Sy;
queue<point3d> Qp;
queue<int> Qd;

#define mapP(POINT) map[POINT.z][POINT.y][POINT.x]

void init(){
	int x,y,z; x=1;
	map = new char**[16];
	for(z=0;z<16;++z){
		map[z] = new char *[mapmaxl];
		for(y=0;y<mapmaxl;++y){
			map[z][y] = new char[mapmaxl+1];
#ifdef DEB
			for(x=0;x<mapmaxl;++x) map[z][y][x] = ' '; //czyszczenie tylko dla kosmetyki printDEBa
#endif
		};
	};
};

void clearmap(){
#ifdef DEB
	int x,y,z;
	for(z=0;z<16;++z) for(y=0;y<mapmaxl;++y) for(x=0;x<mapmaxl;++x) map[z][y][z] = ' '; //for better printDEB
#endif
};

char *sbuf = new char[mapmaxl+1];

bool initset(){
	int x,y,z;
	scanf("%d", &R);
	if(R==0) return false;
	scanf("%d", &C);
	Sx=Sy=-1;
	while(!Qd.empty()) Qd.pop();
	while(!Qp.empty()) Qp.pop();
	for(y=0;y<R;++y){
		scanf("%s", sbuf);
		for(z=0; z<16; ++z)
			strcpy( map[z][y], sbuf);
		for(x=0; x<C; ++x)
			if( sbuf[x] == '*' ) {
				Sx = x;
				Sy = y;
			};
	};
	//if( Sx==-1 ){ printf("NO START POINT!!!\n"); };
	return true;
};

//XOR difference of state
int j(char in){ //KEYS
	switch(in){
		case 'b' : return 1; break;
		case 'y' : return 2; break;
		case 'r' : return 4; break;
		case 'g' : return 8; break;
		case MRK : return -1; break;
		case '#' : return -2; break;
	};
	return 0;
};

//XOR difference of state
int J(char in){ //DOORS
	switch(in){
		case 'B' : return 1; break;
		case 'Y' : return 2; break;
		case 'R' : return 4; break;
		case 'G' : return 8; break;
	};
	return 0;
};

bool doit(){
	point3d p,np, prevp;
	int d, pcase;
	int keyset;
	char ch;

#ifdef DEB
	printf("---------------NEXT SET------------\n");
#endif
	clearmap();
	if( !initset() ) return false;

	p.set(Sx,Sy,0);
	Qp.push(p);
	Qd.push(0);
	mapP(p) = MRK;

	while(!Qp.empty()){
		p = Qp.front(); Qp.pop();
		d = Qd.front(); Qd.pop();
		mapP(p) = MRK;

		for(pcase=0;pcase<4;++pcase){
			//p.print("114  p=");
			np = nextpoint(p,pcase);
			//np.print("116 np=");
			if(np.x<0 || np.x>=C || np.y<0 || np.y>=R || mapP(np)=='#') continue;
			if(j(mapP(np))<0) continue;
			if( J(mapP(np))!=0 && ((J(mapP(np))&np.z)==0) ){
#ifdef DEB
				printf("%d ", __LINE__);
				np.print("np=","");
				printf("brak key j(np)=%d i np.z=%d\n", j(mapP(np)), np.z);
#endif
				continue;
			};
			keyset = j(mapP(np));
			prevp.set(np.x, np.y, np.z);
			np.keysit( keyset );
#ifdef DEB
			np.print("--- np=","\t"); printf(" keyset=%d mapP(np)=%c\n", keyset, mapP(np) );
#endif
			if(mapP(np) == 'X'){
				printf("Escape possible in %d steps.\n",d+1);
				return true;
			};
			if(mapP(np)!='#'){
				mapP(np) = MRK;
				Qp.push(np);
				Qd.push(d+1);
			};
		};
	};

	printf("The poor student is trapped!\n");
	return true;
};

int main(){
	init();
	while( doit() );
	return 0;
};
