#include<cstdio>
#include<cstdlib>
#include<string>
#include<cstring>
#include<vector>
#include<cmath>
#include<cctype>
#include<queue>
#include<algorithm>
#include<set>
#include<map>
#include<numeric>

using namespace std;

#define FOR(i, a, b) for(int i=(a); i<=(b); i++)
#define FORD(i, a, b) for(int i=(a); i>=(b); i--)
#define REP(i, n) for(int i=0; i<(n); i++)
#define ALL(x) (x).begin(), (x).end()
#define MP make_pair
#define PB push_back
#define X first
#define Y second
#define FI first
#define SE second
#define FORE(i, c) for(__typeof((c).begin) i = (c).begin(); i!=(c).end(); ++i)
#define SIZE(x) ((int)(x).size())

typedef vector<int> VI;
typedef long long ll;
typedef pair<int, int> PII;
typedef vector<string> VS;

VS t;
int n,m;
char st[300];
int c[300][300];

int x[]={1,-1,0,0};
int y[]={0,0,1,-1};

inline bool ins(int a,int b)
{
    return a>=0 && a<n && b>=0 && b<SIZE(t[a]);
}

vector<PII> pom;

void dfshash(int a,int b)
{
    c[a][b]=1;
    pom.PB(MP(a,b));
    REP(z,4)
    {
	int u=a+x[z],v=b+y[z];
	if (ins(u,v) && !c[u][v] && t[u][v]=='#') dfshash(u,v);
    }
}

int N;
struct vertex
{
    int typ; // 0,1,2
    int name;
    int typ2;
    int val;
};

vector<vertex> vert;
vector<PII> graf[210][210];
int mojv[210][210];

inline bool dobre(int a,int b)
{
    return ins(a,b) && t[a][b]!='x';
}

inline void add(PII p,PII q)
{
    graf[p.FI][p.SE].PB(q);
    graf[q.FI][q.SE].PB(p);
}

void buduj()
{
    // =, _, |
    REP(i,n) REP(j,SIZE(t[i])) if (t[i][j]=='=' || t[i][j]=='-')
    {
	if (dobre(i,j-1)) add(MP(i,j-1),MP(i,j));
	if (dobre(i,j+1)) add(MP(i,j+1),MP(i,j));
    }
    REP(i,n) REP(j,SIZE(t[i])) if (t[i][j]=='|')
    {
	if (dobre(i-1,j)) add(MP(i-1,j),MP(i,j));
	if (dobre(i+1,j)) add(MP(i+1,j),MP(i,j));
    }
    // +
    REP(i,n) REP(j,SIZE(t[i])) if (t[i][j]=='+')
    {
	if (dobre(i,j-1) && (t[i][j-1]=='-' || t[i][j-1]=='+' || t[i][j-1]=='='))
	    add(MP(i,j-1),MP(i,j));
	if (dobre(i,j+1) && (t[i][j+1]=='-' || t[i][j+1]=='+' || t[i][j+1]=='='))
	    add(MP(i,j+1),MP(i,j));
	if (dobre(i-1,j) && (t[i-1][j]=='|' || t[i-1][j]=='+'))
	    add(MP(i-1,j),MP(i,j));
	if (dobre(i+1,j) && (t[i+1][j]=='|' || t[i+1][j]=='+'))
	    add(MP(i+1,j),MP(i,j));
    }
    // x
    REP(i,n)
    {
	int j=0;
	while (j<SIZE(t[i]))
	{
	    int j0=j;
	    while (j0<SIZE(t[i]) && t[i][j0]=='x') j0++;
	    if (j0==j) { j++; continue; }
	    add(MP(i,j-1),MP(i,j0));
	    j=j0;
	}
    }
    REP(j,m)
    {
	int i=0;
	while (i<n)
	{
	    int i0=i;
	    while (ins(i0,j) && i0<n && t[i0][j]=='x') i0++;
	    if (i0==i) { i++; continue; }
	    add(MP(i-1,j),MP(i0,j));
	    i=i0;
	}
    }
}

VI vv;

void dfs(int a,int b)
{
    c[a][b]=1;
    pom.PB(MP(a,b));
    if (mojv[a][b]>=0) vv.PB(mojv[a][b]);
    REP(i,SIZE(graf[a][b]))
    {
	PII p=graf[a][b][i];
	if (!c[p.FI][p.SE]) dfs(p.FI,p.SE);
    }
}

VI tab[200*200+10],tab1[200*200+10];

void przeszuk()
{
    REP(i,n) REP(j,m) c[i][j]=0;
    REP(i,N) { tab[i].clear(); tab1[i].clear(); }
    REP(i,n) REP(j,m) if (!c[i][j] && !graf[i][j].empty())
    {
	vv.clear(); pom.clear();
	dfs(i,j);
	if (vv.empty()) continue;
	sort(ALL(vv));
	vv.erase(unique(ALL(vv)),vv.end());
//	printf("jajo: ");
//	REP(k,SIZE(vv)) printf("%d ",vv[k]); puts("");
	int kto=-1;
	REP(k,SIZE(pom))
	{
	    PII p=pom[k];
	    if (t[p.FI][p.SE]=='=' && mojv[p.FI][p.SE-1]>=0)
	    {
		kto=mojv[p.FI][p.SE-1];
	    }
	}
//	printf("tu %d\n",kto);
	REP(k,SIZE(vv)) if (vv[k]!=kto)
	{
//	    printf("%d %d\n",vv[k],kto);
	    tab[kto].PB(vv[k]); tab1[vv[k]].PB(kto);
	}
    }
}

int indeg[200*200+10];
VI kol;

inline void wartosc(int v)
{
    if (vert[v].typ==0) return;
    if (vert[v].typ==1) { vert[v].val=vert[tab1[v][0]].val; return; }
    if (vert[v].name==0)
    {
	bool ok=0;
	REP(i,SIZE(tab1[v])) if (vert[tab1[v][i]].val==1) ok=1;
	vert[v].val=vert[v].typ2 ? !ok : ok;
	return;
    }
    if (vert[v].name==1)
    {
	bool ok=1;
	REP(i,SIZE(tab1[v])) if (vert[tab1[v][i]].val==0) ok=0;
	vert[v].val=vert[v].typ2 ? !ok : ok;
	return;
    }
    int il=0;
    REP(i,SIZE(tab1[v])) if (vert[tab1[v][i]].val==1) il++;
    bool ok;
    ok=il%2;
    vert[v].val=(vert[v].typ2 ? !ok : ok);
}

int wyniki[300];

void topo()
{
    REP(i,N) indeg[i]=0;
    REP(i,N) if (vert[i].typ==0) vert[i].val=vert[i].name;
    REP(i,N) indeg[i]=SIZE(tab1[i]);
    kol.clear();
    REP(i,N) if (!indeg[i]) kol.PB(i);
    while (!kol.empty())
    {
	int v=kol.back(); kol.pop_back();
	wartosc(v);
	REP(i,SIZE(tab[v]))
	{
	    indeg[tab[v][i]]--;
	    if (!indeg[tab[v][i]]) kol.PB(tab[v][i]);
	}
    }
    REP(i,300) wyniki[i]=-1;
    REP(i,N) if (vert[i].typ==1) wyniki[vert[i].name]=vert[i].val;
    REP(i,26) if (wyniki[i]>=0) printf("%c=%d\n",char('A'+i),wyniki[i]);
    puts("");
}

void doit()
{
    vert.clear();
    N=0;
    n=SIZE(t); m=200;
    REP(i,n) REP(j,m) { c[i][j]=0; graf[i][j].clear(); mojv[i][j]=-1; }
    // ###
    REP(i,n) REP(j,SIZE(t[i])) if (t[i][j]=='#' && !c[i][j])
    {
	pom.clear();
	dfshash(i,j);
	int mi1=300,ma1=-1,mi2=300,ma2=-1;
	REP(k,SIZE(pom))
	{
	    mi1=min(mi1,pom[k].FI);
	    ma1=max(ma1,pom[k].FI);
	    mi2=min(mi2,pom[k].SE);
	    ma2=max(ma2,pom[k].SE);
	}
	vertex gizmo;
	vert.PB(gizmo);
	vert[N].typ=2;
	vert[N].typ2=0;
	FOR(u,mi1,ma1) FOR(v,mi2,ma2)
	{
	    mojv[u][v]=N;
	    c[u][v]=1;
	    if (t[u][v]=='1') vert[N].name=0;
	    else if (t[u][v]=='&') vert[N].name=1;
	    else if (t[u][v]=='=') vert[N].name=2;
	}
	N++;
    }
    // o
    REP(i,n) REP(j,SIZE(t[i])) if (t[i][j]=='o')
    {
	c[i][j]=1;
	mojv[i][j]=mojv[i][j-1];
	vert[mojv[i][j]].typ2=1;
    }
    vertex g;
    // input,output
    REP(i,n) REP(j,SIZE(t[i])) if (!c[i][j])
    {
	if (t[i][j]=='0' || t[i][j]=='1')
	{
	    g.typ=0;
	    g.name=t[i][j]-'0';
	    mojv[i][j]=N;
	    N++;
	    vert.PB(g);
	} else if (isupper(t[i][j]))
	{
	    g.typ=1;
	    g.name=t[i][j]-'A';
	    mojv[i][j]=N;
	    N++;
	    vert.PB(g);
	}
    }
//    printf("%d\n",N);
    buduj();
    przeszuk();
    topo();
}

int main()
{
    while (1)
    {
	t.clear();
	while (1)
	{
	    fgets(st,250,stdin);
	    if (st[0]=='*') break;
	    int l=strlen(st);
	    while (st[l-1]==10 || st[l-1]==13) l--;
	    t.PB(string(st,st+l));
	}
	if (t.empty()) break;
	doit();
    }
    return 0;
}
