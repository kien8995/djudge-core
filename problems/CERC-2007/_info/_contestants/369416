#include <stdio.h>
#include <map>
#include <queue>

#define		F(i, n)			for (i = 0; i < n; i++)
#define		Fcon(i, n, con)		for (i = 0; i < n && (con); i++)
#define		Clear(m)		memset(m, 0, sizeof(m))
#define		MIN(a, b)		((a) < (b) ? (a) : (b))
#define		brkon(con1, con2)	if ((con1) && (con2)) break

using namespace std;

struct sample
{
	long long sort;
	long num;
	long pos;
};

static int comp(const void *p1, const void *p2)
{
	sample *s1 = *((sample **) p1);
	sample *s2 = *((sample **) p2);

	if (s1->sort < s2->sort)
		return -1;
	if (s1->sort > s2->sort)
		return 1;
	return 0;
}

int main()
{
	long i, j, k;
	long n, od, DO;
	//queue<sample*> sams;
	map<long, sample*> m;
	sample *sam;
	sample *a[100000];

	while (1)
	{
		m.clear();
		scanf("%ld", &n);
		brkon(!n, 1);
		F(i, n)
		{
			scanf("%ld", &j);
			sam = new sample;
			sam->num = j;
			sam->pos = i;
			sam->sort = j * 100000 + i;
			a[i] = sam;
			m[i] = sam;
		}
		qsort(a, n, sizeof(sample*), comp);

		F(i, n)
		{
			od = i;
			DO = a[i]->pos;
			//printf("<%ld>", a[i]->num);
			printf(i < n - 1 ? "%ld " : "%ld", DO + 1);
			for (j = od; j <= (od + DO) / 2 - ((DO - od) % 2 == 0 ? 1 : 0); j++)
			{
				m[j]->pos = DO - (j - od);
				m[DO - (j - od)]->pos = j;
				sam = m[j];
				m[j] = m[DO - (j - od)];
				m[DO - (j - od)] = sam;
			}
		}
		printf("\n");
		F(i, n)
			delete a[i];
	}
}
